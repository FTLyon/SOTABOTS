
include equates.a86
include system.a86


		if	PCPM204E
DONTWRITE_PATCH	EQU	YES
ROD_ERROR_PATCH	EQU	YES
		else
DONTWRITE_PATCH	EQU	NO
ROD_ERROR_PATCH	EQU	NO
		endif


		dseg
		extrn	rlr:word
		extrn	bdos_conowner:word
		extrn	date_days:word
		extrn	free_dirnames:word
		extrn	sysvar_144:byte
		extrn	lp_xios_entry:dword
		extrn	free_dirdata:word
		extrn	pq_filesystem:word
		extrn	pq_error:word

		cseg
		public	bdos_init
		public	bdos_main
		public	cwd_for_drive

		extrn	bdos_callback:near

bdos_init:					; DATA XREF: dseg:001Ao
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ
bdos_functions	dw offset DRV_ALLRESET	; DATA XREF: bdos_main+2o bdos:25F7o
		db 1
		dw offset DRV_SET
		db 1
		dw offset F_OPEN
		db 35h
		dw offset F_CLOSE
		db 35h
		dw offset F_SFIRST
		db 25h
		dw offset F_SNEXT
		db 21h
		dw offset F_DELETE
		db 35h
		dw offset F_READ
		db 17h
		dw offset F_WRITE
		db 17h
		dw offset F_MAKE
		db 25h
		dw offset F_RENAME
		db 15h
		dw offset DRV_ALLOCVEC
		db 1
		dw offset DRV_SETRO
		db 1
		dw offset F_ATTRIB
		db 5
		dw offset DRV_DPB
		db 1
		dw offset F_READRAND
		db 1Bh
		dw offset F_WRITERAND
		db 1Bh
		dw offset F_SIZE
		db 19h
		dw offset F_RANDREC
		db 9
		dw offset DRV_RESET
		db 1
		dw offset F_nop
		db 1
		dw offset F_nop
		db 1
		dw offset F_WRITEZF
		db 1Bh
		dw offset F_nop
		db 19h
		dw offset F_nop
		db 19h
		dw offset DRV_SPACE
		db 1
		dw offset DRV_FLUSH
		db 1
		dw offset flush0	; Function 98 entry point
		db 1
		dw offset F_TRUNCATE
		db 9
		dw offset DRV_SETLABEL
		db 5
		dw offset DRV_GETLABEL
		db 1
		dw offset F_TIMEDATE
		db 5
		dw offset F_WRITEXFCB
		db 5
		dw offset F_PASSWD
		db 1
		dw offset F_BDOS_74
		db 15h
		dw offset flush0	; Function 98 entry point
		db 1
		dw offset F_BDOS_75
		db 1

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

f_interrupt:		; CODE XREF: copy$alv+16p delete11+21p
					; ...
		nop	
		iret	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

bdos_main:		; DATA XREF: dseg:0018o
		add	si, cx
		add	si, offset bdos_functions
		call	bdos_switch
		mov	ax, bx
		retn	


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fs_altentry:				; CODE XREF: tst$relog+Dj
		mov	cl, fs_function
		xor	ch, ch
		mov	si, cx
		shl	si, 1
		add	si, cx
		add	si, offset bdos_functions
		mov	es, rlr
		mov	dx, fs_param_low
		pushf	
		pop	ax
		cli	
		jmps	bdos_main_alt

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

bdos_switch:		; CODE XREF: bdos_main+6p
		inc	es:proc_indisk
		push	cx
		push	dx
		push	si
		mov	bx, offset pq_filesystem
		mov	cx, 204h
		call	bdos_callback
		pop	si
		pop	dx
		pop	cx
		mov	fs_function, cl
		pushf	
		pop	ax
		cli	
		mov	F_old_ss, ss
		mov	F_old_sp, sp

bdos_main_alt:				; CODE XREF: bdos:2606j
		mov	bx, ds
		mov	ss, bx

		mov	sp, offset F_entry_sp
		push	ax
		popf	
		mov	ax, es:word ptr proc_drive
		mov	word ptr fs_fcbdrive, ax
		mov	ax, es:userDS
		mov	fs_param_ds, ax
		mov	ax, es:userES
		mov	f_ret_es, ax
		push	es
		push	si
		mov	ax, ds
		mov	bx, es
		mov	ds, bx

		mov	es, ax

		mov	si, offset proc_dma
		mov	di, offset userdma
		mov	cx, 18h
		rep movsb
		mov	ds, ax

		mov	ax, userdma
		mov	cl, 4
		shr	ax, cl
		add	userdmaseg, ax
		and	userdma, 0Fh
		mov	cx, 14h
		xor	ax, ax
		mov	di, offset fcbdsk
		rep stosb
		mov	fs_param_low, dx
		mov	linfo, dl
		pop	si
		push	si
		mov	ah, cs:2[si]	; Flags	for this call
		test	ah, 4		; Bit 2: 33-byte FCB present
		jz	no_33_fcb
		call	copy_fcb_33
		jmps	no_36_fcb
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

no_33_fcb:				; CODE XREF: bdos_switch+84j
		test	ah, 8
		jz	no_36_fcb	; Bit 3: 36-byte FCB present
		call	copy_fcb_36
		call	get_record_coun

no_36_fcb:				; CODE XREF: bdos_switch+89j
					; bdos_switch+8Ej
		pop	si
		cmp	fs_sectorcount,	1
		jz	single_call
		test	cs:byte ptr 2[si], 2; Bit 1: Call once	for each sector
					;	specified by BDOS sector count
		jz	single_call
		call	F_repeat_call
		jmps	post_multicall
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

single_call:				; CODE XREF: bdos_switch+9Cj
					; bdos_switch+A3j
		call	F_do_call

post_multicall:				; CODE XREF: bdos_switch+A8j
		mov	cl, cur_fcb_len
		xor	ch, ch
		jcxz	fcb_len_0
		mov	si, offset user_fcb
		mov	di, fs_param_low
		mov	es, fs_param_ds

		rep movsb
		test	fcb_is_for_dir,	0FFh
		jz	fcb_len_0
		mov	di, fs_param_low
		or	es:byte ptr [di], 80h

fcb_len_0:				; CODE XREF: bdos_switch+B3j
					; bdos_switch+C7j
		pop	es
		mov	al, fs_function
		cmp	al, 4
		jz	f_to_proc
		cmp	al, 5
		jz	f_to_proc
		cmp	al, 21h
		jnz	f_switchout

f_to_proc:				; CODE XREF: bdos_switch+D7j
					; bdos_switch+DBj
		mov	si, offset sys_fx
		mov	di, offset proc_fx
		mov	cx, 14h
		rep movsb

f_switchout:				; CODE XREF: bdos_switch+DFj
		mov	ax, f_ret_es
		mov	es:userES, ax
		mov	bx, aret
		pushf	
		pop	ax
		cli	
		mov	ss, F_old_ss

		mov	sp, F_old_sp
		push	ax
		popf	
		mov	al, err_major
		push	bx
		test	al, 0FFh
		jz	fs_release
		push	fs_param_ds
		mov	bx, 0FFFFh
		test	set_if_attrs, 0FFh
		jz	fs_ret_error
		mov	bx, fs_param_low

fs_ret_error:				; CODE XREF: bdos_switch+118j
		push	bx
		mov	ah, error_drive

fs_release:				; CODE XREF: bdos_switch+10Aj
		push	ax
		mov	bx, offset pq_filesystem
		mov	cx, 205h
		call	bdos_callback
		pop	ax
		test	al, 0FFh
		jnz	f_abort
		jmp	f_noabort
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

f_abort:				; CODE XREF: bdos_switch+130j
		push	ax
		mov	bx, offset pq_error
		mov	cx, 204h
		call	bdos_callback
		mov	dx, addr_cpm_error
		call	f_printstring
		pop	ax
		push	ax
		add	ah, 'A'
		mov	byte ptr strColonSpace,	ah
		mov	dx, offset strColonSpace
		call	f_printstring
		pop	ax
		push	ax
		mov	bl, al
		xor	bh, bh
		shl	bx, 1
		mov	bx, error_strings[bx]
		mov	dx, [bx]
		call	f_printstring
		mov	dx, addr_bdos_fn
		call	f_printstring
		pop	ax
		mov	al, es:proc_fx
		mov	ah, '0'
		cmp	al, 100
		jb	f_printdec
		push	ax
		mov	dl, '1'
		call	f_printchar
		pop	ax
		sub	al, 100

f_printdec:				; CODE XREF: bdos_switch+176j
					; bdos_switch+187j
		sub	al, 0Ah
		jb	f_printfile
		inc	ah
		jmps	f_printdec
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

f_printfile:				; CODE XREF: bdos_switch+183j
		push	ax
		mov	dl, ah
		call	f_printchar
		pop	dx
		add	dl, ':'
		call	f_printchar
		pop	si
		pop	dx
		inc	si
		jz	f_filedone
		mov	di, offset errFilename
		push	ds
		push	es
		push	ds
		pop	es

		mov	ds, dx
		mov	cx, 8

print_filename:				; CODE XREF: bdos_switch+1ABj
		lodsb
		and	al, 7Fh
		stosb
		loop	print_filename
		mov	al, '.'
		stosb
		mov	cl, 3

print_filetype:				; CODE XREF: bdos_switch+1B6j
		lodsb
		and	al, 7Fh
		stosb
		loop	print_filetype
		pop	es

		pop	ds
		mov	dx, addr_file
		call	f_printstring
		mov	dx, offset errFilename
		call	f_printstring

f_filedone:				; CODE XREF: bdos_switch+199j
		mov	bx, offset pq_error
		mov	cx, 205h
		call	bdos_callback

f_noabort:				; CODE XREF: bdos_switch+132j
		pop	bx
		push	bx
		mov	cx, 206h
		call	bdos_callback
		pop	bx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_do_call:		; CODE XREF: bdos_switch+AAp
					; F_repeat_call+17p
		mov	F_entry_sp, sp
		test	cs:byte ptr 2[si], 20h; Can affect dirs?
		jz	not_for_dir
		test	user_fcb, 80h
		jz	not_for_dir
		and	user_fcb, 1Fh
		mov	fcb_is_for_dir,	0FFh

not_for_dir:				; CODE XREF: F_do_call+9j F_do_call+10j
		test	cs:byte ptr 2[si], 10h
		jz	fs_notfilefcb
		push	si
		call	reselect
		pop	si

fs_notfilefcb:				; CODE XREF: F_do_call+21j
		call	cs:word ptr [si]

F_return:				; CODE XREF: sel$error+27j
		cmp	set_if_attrs, 0
		jz	dont_set_attrs
		mov	al, xfcb_rdonly
		mov	bx, offset user_fcb
		or	7[bx],	al
		mov	al, high$ext
		cmp	al, 60h
		jnz	set_F12
		or	byte ptr 8[bx], 80h
		jmps	dont_set_ifattr
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

set_F12:				; CODE XREF: F_do_call+40j
		or	12[bx], al

dont_set_ifattr:			; CODE XREF: F_do_call+46j
		mov	al, result_F0F
		or	15[bx], al
		mov	al, fcbdsk
		mov	[bx], al

dont_set_attrs:				; CODE XREF: F_do_call+30j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_repeat_call:		; CODE XREF: bdos_switch+A5p
		mov	call_flags, si
		mov	ah, cs:2[si]
		mov	al, fs_sectorcount

frc_loop:				; CODE XREF: F_repeat_call+40j
		mov	last_sec_count,	al
		push	ax
		mov	si, call_flags
		mov	dx, fs_param_low
		call	F_do_call
		mov	bl, byte ptr aret
		or	bl, bl
		pop	ax
		jz	frc_inc
		cmp	bl, 0FFh
		jz	frc_abandon
		mov	bh, fs_sectorcount
		sub	bh, al
		jmps	frc_okay
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

frc_inc:				; CODE XREF: F_repeat_call+21j
		test	ah, 8
		jz	frc_notinc
		call	inc_fcb_record

frc_notinc:				; CODE XREF: F_repeat_call+33j
		add	userdma, 80h
		dec	al
		jnz	frc_loop
		xor	bx, bx

frc_okay:				; CODE XREF: F_repeat_call+2Ej
		mov	aret, bx

frc_abandon:				; CODE XREF: F_repeat_call+26j
		test	ah, 8
		jz	frc_return
		call	fcb_recno_addr
		jmps	put_record_coun



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get_record_coun:		; CODE XREF: bdos_switch+93p
		call	fcb_recno_addr
		xchg	bx, dx

put_record_coun:			; CODE XREF: F_repeat_call+50j
		mov	cl, 3
		jmp	move		; Copy CL bytes	from DX	to BX



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fcb_recno_addr:		; CODE XREF: F_repeat_call+4Dp
					; get_record_counp
		mov	bx, offset user_fcb+21h
		mov	dx, offset fcb_randrec_num
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

copy_fcb_33:		; CODE XREF: bdos_switch+86p
					; bdos:462Ep
		mov	cl, 21h
		jmps	copy_fcb



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

copy_fcb_36:		; CODE XREF: bdos_switch+90p
		mov	cl, 24h

copy_fcb:				; CODE XREF: copy_fcb_33+2j
					; F_PASSWD+2p
		mov	cur_fcb_len, cl
		xor	ch, ch
		mov	si, fs_param_low
		mov	di, offset user_fcb
		push	ds
		mov	ds, fs_param_ds
		rep movsb
		pop	ds

frc_return:				; CODE XREF: F_repeat_call+4Bj
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

inc_fcb_record:		; CODE XREF: F_repeat_call+35p
		mov	bx, offset user_fcb+21h
		inc	word ptr [bx]
		jnz	ifr_ret
		inc	byte ptr 2[bx]

ifr_ret:				; CODE XREF: inc_fcb_record+5j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

f_printchar:		; CODE XREF: bdos_switch+17Bp
					; bdos_switch+18Cp ...
		mov	cx, 419h
		jmp	bdos_callback



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

f_printstring:		; CODE XREF: bdos_switch+143p
					; bdos_switch+152p ...
		mov	bx, dx

f_prstr_loop:				; CODE XREF: f_printstring+Fj
		mov	dl, [bx]
		cmp	dl, '$'
		jz	f_prstr_end
		push	bx
		call	f_printchar
		pop	bx
		inc	bx
		jmps	f_prstr_loop
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

f_prstr_end:				; CODE XREF: f_printstring+7j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fs_call_xios:		; CODE XREF: drive_login+5p
					; DRV_FLUSH+9p	...
		push	es
		mov	es, rlr
		callf	dword ptr lp_xios_entry
		cld	
		pop	es
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

xios_rdwr:		; CODE XREF: wrbuff+2p	rdbuff+2p
					; ...
		mov	dx, bcb_record
		mov	ch, bcb_record_h
		mov	bl, curdsk
		mov	bh, 1
		xchg	bh, fs_rdwrcount
		push	bx
		push	fs_track
		push	fs_sector
		push	word ptr fs_buffer
		push	word ptr fs_buffer+2
		mov	es, rlr
		callf	dword ptr lp_xios_entry
		add	sp, 0Ah
		cld	
		push	ds
		pop	es

		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fs_abort1:		; CODE XREF: rdbuff+74j
		mov	ah, 1
		jmps	goerr


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ
;

rod$error:
		call	discard$dir	; Report read/only disk	error
	if ROD_ERROR_PATCH
		jmp	rod_err_patch
		nop
	else
		mov	ah, 2
		jmps	goerr
	endif	

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

rof$error:		; CODE XREF: check$rodir+8j
					; fat_delete+34j ...
		mov	ah, 3
		jmps	goerr



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Report select	error

sel$error:		; CODE XREF: cwd_for_drive+2Bj
		mov	curdsk,	0FFh	; Invalidate curdsk to force select
					; call at next curselect call
		mov	ah, 4

goerr:					; CODE XREF: fs_abort1+2j rof$error+2j
					; ...
		mov	al, 0FFh
		mov	aret, ax
		cmp	fs_errormode, al
		jnz	error

rtn$phy$errs:				; CODE XREF: error+Fj error+23j
		mov	al, fs_function
		cmp	al, 0Bh		; Return 0ffffh	if function 27 or 31
		jz	fs_abort_ffff
		cmp	al, 0Eh
		jnz	goback

fs_abort_ffff:				; CODE XREF: sel$error+17j
		mov	aret, 0FFFFh

goback:					; CODE XREF: sel$error+1Bj
					; disk_error+10j ...
		mov	sp, F_entry_sp
		jmp	F_return



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

f_ret_1:		; CODE XREF: open$reel+79j
					; open$reel+97j ...
		mov	al, 1

sta$ret:				; CODE XREF: check_changed+11j
					; tst$inv$fcb+8j ...
		mov	byte ptr aret, al

F_nop:					; DATA XREF: bdos:25AAo bdos:25ADo
					; ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

disk_error:		; CODE XREF: valid_dl_f_fcb+Aj
					; cpm_writerec+17j ...
		mov	al, 0FFh
		mov	aret, ax
		cmp	ah, 3		; Error	3 -> Error 12
		jnz	diskerr_not3
		mov	ah, 0Ch

diskerr_not3:				; CODE XREF: disk_error+8j
		cmp	fs_errormode, al
		jz	goback



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

error:		; CODE XREF: sel$error+10j
		mov	err_major, ah
		mov	al, fs_fcbdrive
		mov	error_drive, al
		cmp	fs_errormode, 0FEh
		jz	rtn$phy$errs
		push	ds
		mov	ds, rlr

		or	proc_flags, 1
		mov	proc_errcode, 0FFFDh
		pop	ds

		jmps	rtn$phy$errs



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Copy CL bytes	from DX	to BX

move:		; CODE XREF: get_record_coun+7j
					; deblock+100p	...
		xor	ch, ch
		mov	si, dx
		mov	di, bx
		rep movsb
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Compare CL bytes at DX and BX

compare:		; CODE XREF: discard$data+Cp
					; get$bcba+5Bp	...
		xor	ch, ch
		mov	si, bx
		mov	di, dx
		rep cmpsb
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

seek:		; CODE XREF: bdos:2C5Dp deblock$io+1p
					; ...
		mov	ax, bcb_record
		xor	dx, dx
		mov	dl, bcb_record_h
		mov	cl, dpb_psh
		xor	ch, ch
		jcxz	lookup_p128

lookup_shift:				; CODE XREF: seek+15j
		shr	dx, 1
		rcr	ax, 1
		loop	lookup_shift

lookup_p128:				; CODE XREF: seek+Fj
		cmp	F_isfatfs, 0
		jz	lookup_cpm
		add	ax, dpb_firstfat
		adc	dx, 0
		xchg	ax, bx
		mov	al, byte ptr dpb_fatcount
		mul	byte ptr dpb_secperfat
		add	ax, bx
		adc	dx, 0
		div	dpb_spt
		jmps	lookup_haveoffs
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

lookup_cpm:				; CODE XREF: seek+1Cj
		div	dpb_spt
		add	ax, dpb_off

lookup_haveoffs:			; CODE XREF: seek+36j
		mov	fs_track, ax
		mov	fs_sector, dx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

atran:		; CODE XREF: bdos:3D15p cpm_writerec+96p
		mov	cl, dpb_bsh
		mov	ax, bcb_record
		mov	arecord1, ax
		xor	bh, bh
		mov	bl, ah
		shl	ax, cl
		shl	bx, cl
		mov	bcb_dirty, ax
		xchg	ax, bx
		mov	al, vrecord
		and	al, dpb_blm
		mov	blk$off, al
		or	bl, al
		mov	bcb_record, bx
		mov	bcb_record_h, ah
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

dm$position:		; CODE XREF: indexp check$nprs+77p
					; ...
		mov	cl, dpb_bsh
		mov	ch, vrecord
		shr	ch, cl
		neg	cl
		add	cl, 7
		mov	al, extval
		shl	al, cl
		add	al, ch
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Get block CX from FCB; returns in BX

get$dm:		; CODE XREF: index+Ap check$nprs+8Ap
					; ...
		mov	bx, offset user_fcb+10h
		add	bx, cx
		cmp	single,	0	; Nonzero if using 8-bit blocks
		jz	bffcb_16bit
		mov	bl, [bx]
		xor	bh, bh
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

bffcb_16bit:				; CODE XREF: get$dm+Aj
		add	bx, cx
		mov	bx, [bx]
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Compute disk block number from current FCB

index:		; CODE XREF: bdos:3D10p cpm_writerec+42p
		call	dm$position
		mov	dminx, al
		mov	cl, al
		xor	ch, ch
		call	get$dm		; Get block CX from FCB; returns in BX
		mov	bcb_record, bx
		or	bx, bx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get$atts:		; CODE XREF: cpm_deletep F_MAKE+31p
					; ...
		mov	di, offset user_fcb+8
		mov	cx, 4
		xor	dl, dl
		std	

get_attrs0:				; CODE XREF: get$atts+12j
		mov	al, [di]
		shl	al, 1
		rcr	dl, 1
		shr	al, 1
		stosb
		loop	get_attrs0
		cld	
		mov	al, dl
		mov	attributes, al	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Compute directory extent from	FCB

get$dir$ext:		; CODE XREF: getfcb+Dp	open$copy+16p
					; ...
		mov	bx, offset user_fcb+20h
		mov	dx, 1001h	; Scan FCB disk	map backwards

get$de0:				; CODE XREF: get$dir$ext+10j
					; get$dir$ext+31j
		dec	dh
		dec	bx
		cmp	byte ptr [bx], 0
		jnz	get$de2		; fcb(dskmap(bx)) ~= 0
		or	dh, dh
		jnz	get$de0
		dec	dl		; DL=0 if all blocks are 0 in fcb
					; disk map

get$de2:				; CODE XREF: get$dir$ext+Cj
		mov	dminx, dl
		cmp	single,	0FFh	; Nonzero if using 8-bit blocks
		mov	al, dh
		jz	get$de3
		shr	al, 1		; not single, divide blk idx by	2
;
; Compute ext offset from last non-zero	block index
; by shifting blk idx right by (7 - block shift)
;

get$de3:				; CODE XREF: get$dir$ext+1Fj
		mov	cl, 7
		sub	cl, dpb_bsh
		shr	al, cl
		mov	ah, dpb_exm
		cmp	ah, al		; Verify computed extent <= ext	mask
		jb	get$de0
		mov	bx, offset user_fcb+0Ch
		mov	cl, [bx]	; Extent
		not	ah
		and	ah, 1Fh		; dir ext = (fcb ext & (~extmsk) & maxext) | ext offset
		and	ah, cl
		or	al, ah		; AL = directory extent
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Compare extent nos in	AL and CL
; Return nonzero if they do not	match

compext:		; CODE XREF: bdos:3702p open$reel+Fp
					; ...
		push	cx
		mov	ch, dpb_exm
		not	ch		; CH = mask for	physical extent	no#
		and	cl, ch
		and	al, ch
		sub	al, cl
		and	al, 1Fh		; Difference between 2 phys extents
		pop	cx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Set variables	from currently addressed FCB

getfcb:		; CODE XREF: open$reel+58p
					; bdos:3CF6p ...
		mov	al, user_fcb+20h
		mov	vrecord, al
		cmp	user_fcb+0Fh, 0
		jnz	getfcb0
		call	get$dir$ext	; Compute directory extent from	FCB
		mov	cl, al
		call	set$rc

getfcb0:				; CODE XREF: getfcb+Bj
		mov	al, user_fcb+0Fh
		cmp	al, 81h
		jb	getfcb1
		mov	al, 80h

getfcb1:				; CODE XREF: getfcb+1Aj
		mov	rcount,	al
		mov	al, dpb_exm
		and	al, user_fcb+0Ch
		mov	extval,	al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Place	values back into current FCB

setfcb:		; CODE XREF: bdos:2F06j bdos:3D2Bj
					; ...
		xor	al, al		; Don't change if random
		cmp	fs_function, 9	; Is function <	9? (sequential read/write)
		jnb	setfcb1
		inc	al		; Increase current record

setfcb1:				; CODE XREF: setfcb+7j
		add	al, vrecord
		mov	user_fcb+20h, al
		cmp	user_fcb+0Fh, 80h; Don't reset RC if > 7Fh
		jnb	setfcb2
		mov	al, rcount
		mov	user_fcb+0Fh, al

setfcb2:				; CODE XREF: setfcb+17j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

cksum_cl_bytes:		; CODE XREF: compute$cs+Ep
		xor	ch, ch

cksum8_loop:				; CODE XREF: cksum_cl_bytes+5j
		add	al, [bx]
		inc	bx
		loop	cksum8_loop
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Compute checksum for current directory buffer

compute$cs:		; CODE XREF: r$dir+49p
		mov	bx, buffa
		mov	cx, 4
		xor	ah, ah		; AH=0,CX=4

compute$cs0:				; CODE XREF: compute$cs+14j
		push	cx
		xor	al, al
		mov	cl, 20h
		call	cksum_cl_bytes
		xor	ah, al
		pop	cx
		loop	compute$cs0
		xchg	al, ah		; Return with checksum in AL
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

chek$fcb:		; CODE XREF: check_changedp
					; F_CLOSE+2Cp
		cmp	high$ext, 60h
		jnz	chek$fcb1
		xor	al, al
		mov	user_fcb, al

chek$fcb1:				; CODE XREF: chek$fcb+5j
		mov	bx, lsn$add
		mov	al, user_fcb+0Dh
		cmp	2[bx],	al

d_notchanged:				; CODE XREF: check_changed+3j
					; check_changed+Cj
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

check_changed:		; CODE XREF: F_READp F_WRITEp
					; ...
		call	chek$fcb
		jz	d_notchanged
		mov	dx, removable_drive
		call	test$vector	; Return bit curdsk of vector DX
		jz	d_notchanged
		pop	bx

chk$media2:				; CODE XREF: chk$exit$fxs+Cj
		mov	al, 0Ah
		jmp	sta$ret



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set$lsn:		; CODE XREF: open$reel+55p
					; cpm_rwrand+ABp ...
		mov	bx, lsn$add
		mov	cl, 2[bx]
		mov	user_fcb+0Dh, cl
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set$cdisk:		; CODE XREF: media$change+12p
					; curselect+2Cp ...
		mov	cl, curdsk

set$cdisk1:				; CODE XREF: get$block+3Bp
		mov	ax, 1
		shl	ax, cl
		or	[bx], ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Return true if drive is software R/O

nowrite:		; CODE XREF: check$writep r$dir+63p
					; ...
		mov	dx, readonly_vector



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Return bit curdsk of vector DX

test$vector:		; CODE XREF: check_changed+9p
					; rdbuff+2Cp ...
		mov	cl, curdsk
		shr	dx, cl
		and	dx, 1
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

getdptra:		; CODE XREF: check$rodirp read$subdir+33p
					; ...
		mov	bl, dptr
		xor	bh, bh
		add	bx, buffa
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

cpm_getrdonly:		; CODE XREF: check$rodir+3p
		add	bx, 9
		mov	al, [bx]
		rcl	al, 1

can_write:				; CODE XREF: check$rodir+6j
					; check$write+3j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

check$rodir:		; CODE XREF: cpm_delete+1Dp
					; bdos:47E5p ...
		call	getdptra

check$rofile:				; CODE XREF: cpm_writerec+24p
					; fat_rdwr+22p
		call	cpm_getrdonly
		jnb	can_write
		jmp	rof$error



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

check$write:		; CODE XREF: seek$copyp cpm_writerec+5p
					; ...
		call	nowrite		; Return true if drive is software R/O
		jz	can_write
		jmp	rod$error	; Report read/only disk	error



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

getmodnum:		; CODE XREF: setfwfp cpm_writerec+136p
		mov	bx, offset user_fcb+0Eh
		mov	al, [bx]
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Clear	S2 byte	of FCB

clrmodnum:		; CODE XREF: F_OPEN+3p	F_SFIRST+30p
					; ...
		mov	user_fcb+0Eh, 0
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

clr$ext:		; CODE XREF: reselect+24p F_SFIRST+2Dp
					; ...
		and	user_fcb+0Ch, 1Fh
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

setfwf:		; CODE XREF: open$copyp close$fcb+9Bp
					; ...
		call	getmodnum
		or	al, 80h
		mov	[bx], al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

cp_fcb10_ffff:		; CODE XREF: tst$inv$fcbp close+11p
					; ...
		mov	bx, offset user_fcb+10h
		jmps	cp_pbx_ffff



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

tst$inv$fcb:		; CODE XREF: bdos:3CEEp cpm_writerec+27p
		call	cp_fcb10_ffff
		jnz	eod_ret
		pop	bx
		mov	al, 9
		jmp	sta$ret



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

end$of$dir:		; CODE XREF: read$subdir+2Bp
					; cpm_login+4Bp ...
		mov	bx, offset dcnt

cp_pbx_ffff:				; CODE XREF: cp_fcb10_ffff+3j
		cmp	word ptr [bx], 0FFFFh

eod_ret:				; CODE XREF: tst$inv$fcb+3j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set$end$dir:		; CODE XREF: rd$subdir1+3Bj
					; r$dir+11j ...
		mov	dcnt, 0FFFFh
		mov	dname_cluster, 0
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set_dcnt_dblk:		; CODE XREF: does$xfcb$exist+7p
					; restore_dir_fcbp ...
		mov	ax, xdcnt
		and	al, 0FCh
		dec	ax
		mov	dcnt, ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

compcdr:		; CODE XREF: setcdrp searchn+20p
					; ...
		mov	dx, dcnt
		mov	bx, cdrmaxa
		cmp	dx, [bx]

tst$relog_ret:				; CODE XREF: setcdr+3j	tst$log$fxs+5j
					; ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

setcdr:		; CODE XREF: cpm_login+72p
					; fat_login+4Cp ...
		call	compcdr
		jb	tst$relog_ret
		inc	dx
		mov	[bx], dx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

tst$log$fxs:		; CODE XREF: search$h_sub+23p
					; reselect+46p
		test	byte ptr dpb_cks+1, 80h
		jnz	tst$relog_ret
		mov	di, offset log$fxs



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

tst$log0:		; CODE XREF: chk$exit$fxs+7p
					; chk$exit$fxs+12p
		mov	cl, cs:[di]
		inc	di
		xor	ch, ch
		mov	al, fs_function
		push	cs
		pop	es

		repne scasb
		push	ds
		pop	es

		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

chk$exit$fxs:		; CODE XREF: rdbuff+4Cp read$dir+Ap
					; ...
		mov	bx, offset goback
		push	bx
		mov	di, offset rw$fxs; Read	or write functions
		call	tst$log0
		jnz	chk_exit_fxs1
		jmp	chk$media2
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

chk_exit_fxs1:				; CODE XREF: chk$exit$fxs+Aj
		mov	di, offset sc$fxs; Close or search functions
		call	tst$log0
		jnz	chk_exit_fxs2
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

chk_exit_fxs2:				; CODE XREF: chk$exit$fxs+15j
		pop	bx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

tst$relog:		; CODE XREF: read$dir+Dp rd$parentdir+64j
		xor	al, al
		xchg	al, relog
		test	al, al
		jz	tst$relog_ret
		call	curselect
		jmp	fs_altentry



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

drv$relog:		; CODE XREF: check$media+3Ap
		call	curselect
		xor	ax, ax
		mov	dcnt, ax
		mov	dptr, al
		retn	


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

recordok1:				; CODE XREF: fat_rdwr_ckd+16j
		mov	fs_rdwrcount, al
		push	cx
		call	setdata
		call	seek
		pop	cx
		or	cl, cl
		jz	wrbuff
		jmps	rdbuff

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

wrbuff:		; CODE XREF: bdos:2C63j deblock$io+Dj
					; ...
		mov	al, 0Bh
		call	xios_rdwr
		mov	ah, 0FFh
		jmps	diocomp1



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

rdbuff:		; CODE XREF: bdos:2C65j deblock$io+10p
					; ...
		mov	al, 0Ah
		call	xios_rdwr

diocomp:				; CODE XREF: DRV_FLUSH+Cp call_xios_flush+5p
		mov	ah, 0

diocomp1:				; CODE XREF: wrbuff+7j	write_FAT+3Fj
		or	al, al
		jnz	diocomp2
		mov	readf$sw, 0FFh
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

diocomp2:				; CODE XREF: rdbuff+9j
		push	ax
		push	bx
		cmp	al, 0FFh	; AL = 0FFh => media changed
		jz	diocomp_chg
		mov	al, bcb_drive
		cmp	al, fs_fcbdrive
		jz	diocomp_nochang

diocomp_chg:				; CODE XREF: rdbuff+15j
		cmp	dpb_cks, 8000h
		jz	diocomp_nochang
		mov	dx, login_vector
		call	test$vector	; Return bit curdsk of vector DX
		jz	diocomp_nochang
		call	media$change
		cmp	fs_function, 1Ah; Was this a flush operation?
		jz	wasflush
		mov	al, bcb_drive
		cmp	al, fs_fcbdrive
		jz	diocomp_notrelg	; To another drive?
		mov	relog, 0

wasflush:				; CODE XREF: rdbuff+39j
		pop	bx
		pop	ax
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

diocomp_notrelg:			; CODE XREF: rdbuff+42j
		call	chk$exit$fxs
		test	readf$sw, 0FFh	; Was this a directory read?
		jz	diocomp9
		call	lret$eq$ff
		jmp	goback
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

diocomp9:				; CODE XREF: rdbuff+54j
		pop	bx
		pop	ax
		or	ah, ah
		jnz	j_rod$error
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

diocomp_nochang:			; CODE XREF: rdbuff+1Ej rdbuff+26j
					; ...
		pop	bx
		pop	ax
		push	es
		mov	es, rlr

		mov	es:byte ptr proc_countdown, bh
		pop	es
		cmp	al, 2
		jz	j_rod$error
		jmp	fs_abort1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

j_rod$error:				; CODE XREF: rdbuff+60j rdbuff+72j
		jmp	rod$error	; Report read/only disk	error



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Release the BCB for bcb_drive, record	bcb_record

discard$databcb:		; CODE XREF: cpm_writerec+C4p
					; cpm_writerec+F8p ...
		mov	bx, dph_dtabcb
		mov	cl, 4
		jmps	bcb_rel_cl



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Release all directory	BCBs for a drive

discard$dir:		; CODE XREF: bdos:291Dp cpm_login+19p
					; ...
		mov	bx, dph_dirbcb



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Called with BX->BCB chain head. Release all BCBs for a drive

discard$data:		; CODE XREF: media$change+4p
					; cpm_login+16p ...
		mov	cl, 1

bcb_rel_cl:				; CODE XREF: discard$databcb+6j
		or	bx, bx
		jz	no_bcb_chain
		mov	bx, [bx]	; BX ->	first BCB

bcbrel_loop:				; CODE XREF: discard$data+1Aj
		push	cx
		mov	dx, offset bcb_drive
		call	compare		; Compare CL bytes at DX and BX
		pop	cx
		jnz	bcbrel_next
		mov	byte ptr [bx], 0FFh

bcbrel_next:				; CODE XREF: discard$data+10j
		mov	bx, 12[bx]	; Next BCB
		or	bx, bx
		jnz	bcbrel_loop

no_bcb_chain:				; CODE XREF: discard$data+4j
					; proc$discard+2j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Free BCBs on bcb_drive used by current process

proc$discard:		; CODE XREF: DRV_FLUSH+6Fp
		or	bx, bx
		jz	no_bcb_chain
		mov	bx, [bx]

fpbcb_loop:				; CODE XREF: proc$discard+2Fj
		mov	al, [bx]
		cmp	al, bcb_drive
		jnz	fpbcb_next
		mov	ax, 14[bx]	; Owned	by current process?
		cmp	ax, rlr
		jnz	fpbcb_next
		mov	word ptr 14[bx], 0
		mov	al, fs_function
		cmp	al, 1Ah		; Set DMA
		jz	fpbcb_freeit
		cmp	al, 15h		; F_WRITE
		jnz	fpbcb_next

fpbcb_freeit:				; CODE XREF: proc$discard+21j
		mov	byte ptr [bx], 0FFh

fpbcb_next:				; CODE XREF: proc$discard+Cj
					; proc$discard+15j ...
		mov	bx, 12[bx]
		or	bx, bx
		jnz	fpbcb_loop
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get$bcba:		; CODE XREF: deblock+90p
		mov	rootbcba, bx
		mov	di, bx
		sub	di, 0Ch
		mov	bx, [bx]	; BX->BCB. DI->prev BCB
		cmp	word ptr 12[bx], 0
		jnz	get$bcb05
		jmp	gcbca_end	; No BCB follows
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

get$bcb05:				; CODE XREF: get$bcba+Fj
		xor	ax, ax
		mov	emptybcba, ax
		mov	seqbcba, ax
		mov	my_bcbs, al	; BCBs owned by	this process

get$bcb1:				; CODE XREF: get$bcba+CEj
		cmp	byte ptr [bx], 0FFh
		jz	got_free_bcb
		mov	ax, 14[bx]
		or	ax, ax
		jnz	has_owner
		mov	si, emptybcba
		or	si, si
		jz	got_free_bcb
		mov	si, 12[si]
		cmp	byte ptr [si], 0FFh
		jz	get$bcb14

got_free_bcb:				; CODE XREF: get$bcba+22j get$bcba+31j
		mov	emptybcba, di
		mov	byte ptr 5[bx], 0
		jmps	get$bcb14
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

has_owner:				; CODE XREF: get$bcba+29j
		cmp	ax, rlr
		jnz	get$bcb14
		inc	my_bcbs		; BCBs owned by	this process
		mov	seqbcba, di

get$bcb14:				; CODE XREF: get$bcba+39j get$bcba+43j
					; ...
		mov	curbcba, bx
		push	di
		call	set$arecord
		call	compare		; Compare CL bytes at DX and BX
		pop	di
		mov	bx, curbcba
		jnz	get$bcb17
		mov	al, 5[bx]
		cmp	al, 0FFh
		jz	get$bcb16
		mov	ah, phy$off
		cmp	al, ah
		jz	get$bcb16
		inc	al
		cmp	al, ah
		jz	get$bcb15
		mov	al, 0FFh

get$bcb15:				; CODE XREF: get$bcba+78j
		mov	5[bx],	al

get$bcb16:				; CODE XREF: get$bcba+6Aj get$bcba+72j
		jmp	get$bcb5
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

get$bcb17:				; CODE XREF: get$bcba+63j
		mov	ax, 14[bx]
		cmp	ax, rlr
		jnz	get$bcb19
		mov	al, bcb_drive
		cmp	al, [bx]
		jnz	get$bcb19
		mov	al, dpb_phm
		or	al, al
		jz	get$bcb19
		cmp	al, 5[bx]
		jnz	get$bcb19
		mov	byte ptr 5[bx], 0
		cmp	word ptr 12[bx], 0
		jz	get$bcb21
		dec	my_bcbs		; BCBs owned by	this process
		xor	ax, ax
		xchg	ax, 12[bx]
		mov	12[di], ax
		xchg	ax, bx

get$bcb18:				; CODE XREF: get$bcba+BCj
		mov	si, bx
		mov	bx, 12[si]
		or	bx, bx
		jnz	get$bcb18
		mov	12[si], ax
		jmps	get$bcb20
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

get$bcb19:				; CODE XREF: get$bcba+89j get$bcba+90j
					; ...
		cmp	word ptr 12[bx], 0
		jz	get$bcb21
		mov	di, bx

get$bcb20:				; CODE XREF: get$bcba+C1j
		mov	bx, 12[di]
		jmp	get$bcb1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

get$bcb21:				; CODE XREF: get$bcba+A6j get$bcba+C7j
		mov	si, emptybcba
		or	si, si
		jz	get$bcb22
		mov	di, si

get$bcb22:				; CODE XREF: get$bcba+D7j
		mov	si, rootbcba
		mov	al, my_bcbs	; BCBs owned by	this process
		cmp	al, 2[si]
		jb	get$bcb23
		mov	di, seqbcba

get$bcb23:				; CODE XREF: get$bcba+E5j
		mov	bx, 12[di]
		mov	al, phy$off
		mov	5[bx],	al

get$bcb5:				; CODE XREF: get$bcba+7Fj
		mov	si, rootbcba
		mov	ax, [si]
		cmp	ax, bx
		jz	gcbca_end
		xchg	ax, 12[bx]
		mov	12[di], ax
		mov	[si], bx

gcbca_end:				; CODE XREF: get$bcba+11j get$bcba+FCj
		mov	ax, rlr
		mov	14[bx], ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Take the last	LRU buffer, move to head of chain,
; allocate to drive bcb_drive block DX

lru_touch:		; CODE XREF: cpm_writerec+71p
		mov	bx, offset p_lru_first

lru_goto_end:				; CODE XREF: lru_touch+Aj
		mov	di, bx		; DI->previous entry
		mov	bx, [bx]
		cmp	word ptr [bx], 0
		jnz	lru_goto_end
;
; BX->last entry in LRU	chain
; DI->the one pointing to it
;
		mov	al, bcb_drive
		mov	4[bx],	al
		mov	2[bx],	dx
		xor	ax, ax
		mov	5[bx],	al
		mov	[di], ax	; Detach from chain
		mov	ax, bx
		xchg	ax, p_lru_first	; Move to head of chain
		mov	[bx], ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Free all LRU buffers for drive bcb_drive

lru_free:		; CODE XREF: copy$alv+1Fp cpm_writerec+FFp
		mov	al, bcb_drive
		mov	bx, offset p_lru_first

lru_free_loop:				; CODE XREF: lru_free+14j
		mov	bx, [bx]
		cmp	4[bx],	al
		jnz	lru_free_next
		mov	byte ptr 4[bx], 0FFh

lru_free_next:				; CODE XREF: lru_free+Bj
		cmp	word ptr [bx], 0
		jnz	lru_free_loop
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Returns Carry	set if buffer dirty?

lru_ckdirty:		; CODE XREF: deblock+11Ep deblock+133p
					; ...
		test	F_isfatfs, 0FFh
		jz	cpm_lrufind
		cmp	fat_buf_dirty?,	0FFh
		cmc	
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_lrufind:				; CODE XREF: lru_ckdirty+5j
		mov	al, bcb_drive
		mov	bx, offset p_lru_first
		mov	dx, arecord1

lrufind_loop:				; CODE XREF: lru_ckdirty+3Dj
		mov	bx, [bx]
		cmp	4[bx],	al	; Drive	match?
		jnz	lrufind_next
		cmp	2[bx],	dx	; Record match?
		jnz	lrufind_next
		cmp	cl, 5[bx]
		jb	lrufind_end
		mov	al, dpb_phm
		mov	ah, al
		not	ah
		and	cl, ah
		inc	al
		add	al, cl
		mov	5[bx],	al

lrufind_end:				; CODE XREF: lru_ckdirty+27j
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

lrufind_next:				; CODE XREF: lru_ckdirty+1Dj
					; lru_ckdirty+22j
		cmp	word ptr [bx], 0
		jnz	lrufind_loop
		stc	
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Read/write a sector and/or update the	current	BCB with its address
; AL=0:	Update BCB
; AL=1:	Read and update
; AL=2:	Write and update

deblock$io:		; CODE XREF: deblock+F6p deblock+125p
					; ...
		push	ax
		call	seek
		pop	ax
		dec	al
		js	rwb_fn0
		jnz	rwb_fn1
		mov	cl, 1
		jmp	wrbuff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

rwb_fn1:				; CODE XREF: deblock$io+9j
		call	rdbuff

rwb_fn0:				; CODE XREF: deblock$io+7j
		mov	si, offset fs_track
		mov	di, curbcba
		add	di, 6
		mov	cx, 2
		rep movsw
		retn	


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

ddta_1:					; CODE XREF: fat_rdwr_ckd+1Dj
		mov	ah, 1
		test	cl, cl
		jnz	ddta_2
		inc	ah

ddta_2:					; CODE XREF: bdos:2EF6j
		mov	fat_buf_dirty?,	ch
		jmp	deblock$dta
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

go_rdbuff:				; CODE XREF: bdos:3D1Fj
		mov	ah, 1
		call	deblock$dta
		jmp	setfcb		; Place	values back into current FCB

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

deblock:		; CODE XREF: bdos:3207p
		mov	word ptr fs_buffer, ds
		mov	bx, dph_dirbcb
		cmp	ah, 5
		jnz	deblock1a
		mov	bx, curbcba
		jmps	deblock1a
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

deblock$dta:				; CODE XREF: bdos:2EFEj bdos:2F03p
					; ...
		mov	bx, dph_dtabcb
		mov	word ptr fs_buffer, 0
		cmp	ah, 4
		jnz	deblock1a

deblock$flush:				; CODE XREF: deblock+74j
		mov	bx, [bx]
		mov	fs_track, 0FFFFh
; Search for dirty BCB with lowest track number

deblock$flush1:				; CODE XREF: deblock+55j
		mov	al, bcb_drive	; Does current drive own BCB?
		cmp	al, [bx]
		jnz	deblock$flush2
		test	byte ptr 4[bx], 0FFh; Is buffer dirty?
		jz	deblock$flush2	; No
		mov	ax, 14[bx]	; Owned	by current process?
		cmp	ax, rlr
		jnz	deblock$flush2	; No
		mov	ax, 6[bx]	; Is bcb(6) < track?
		cmp	ax, fs_track
		jnb	deblock$flush2
		mov	fs_track, ax
		mov	fs_sector, bx

deblock$flush2:				; CODE XREF: deblock+2Fj deblock+35j
					; ...
		mov	bx, 12[bx]
		or	bx, bx		; Got to end yet?
		jnz	deblock$flush1
		cmp	fs_track, 0FFFFh
		jnz	deblock$flush3
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

deblock$flush3:				; CODE XREF: deblock+5Cj
		mov	bx, fs_sector
		xor	al, al
		mov	ah, 4
		mov	word ptr fs_buffer, 0
		call	deblock1a	; Flush	BCB
		mov	bx, dph_dtabcb
		jmps	deblock$flush
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

deblock1a:				; CODE XREF: deblock+Bj deblock+11j
					; ...
		mov	deblock_command, ah
		lahf	
		mov	cl, dpb_phm
		mov	al, byte ptr bcb_record
		and	al, cl
		mov	phy$off, al	; phy$off = low(arecord) & phymsk
		not	cl		; arecord &= ~phymsk
		and	byte ptr bcb_record, cl
		sahf	
		jz	deblock1b
		call	get$bcba

deblock1b:				; CODE XREF: deblock+8Ej
		mov	curbcba, bx
		mov	ax, 10[bx]
		cmp	word ptr fs_buffer, 0
		jnz	deblock1c
		mov	word ptr fs_buffer, ax
		xor	ax, ax

deblock1c:				; CODE XREF: deblock+9Fj
		mov	word ptr fs_buffer+2, ax
		mov	al, deblock_command
		cmp	al, 3
		jnz	deblock1d
		xor	ah, ah
		xchg	ah, dir_check_flag
		test	ah, 0F0h
		jnz	deblock25

deblock1d:				; CODE XREF: deblock+AEj
		call	set$arecord
		cmp	byte ptr [bx], 0FFh
		jz	deblock2
		cmp	al, 4
		jnb	deblock1e
		call	compare		; Compare CL bytes at DX and BX
		jz	deblock2b

deblock1e:				; CODE XREF: deblock+C5j
		cmp	al, 5
		jz	deblock15
		test	byte ptr 4[bx], 0FFh
		jz	deblock2

deblock15:				; CODE XREF: deblock+CEj
		push	word ptr bcb_drive
		push	bcb_record+1
		mov	ax, 2[bx]
		mov	bcb_record+1, ax
		mov	ax, [bx]
		mov	word ptr bcb_drive, ax
		cmp	curdsk,	al
		jz	deblock15a
		call	disk$select1

deblock15a:				; CODE XREF: deblock+EDj
		mov	al, 1
		jnz	deblock15b
		call	deblock$io	; Read/write a sector and/or update the	current	BCB with its address
					; AL=0:	Update BCB
					; AL=1:	Read and update
					; AL=2:	Write and update

deblock15b:				; CODE XREF: deblock+F4j
		call	set$arecord
		mov	byte ptr 4[bx], 0
		call	move		; Copy CL bytes	from DX	to BX
		pop	bcb_record+1
		pop	word ptr bcb_drive
		call	curselect

deblock2:				; CODE XREF: deblock+C1j deblock+D4j
		mov	al, deblock_command
		cmp	al, 4
		jb	deblock2a
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

deblock2a:				; CODE XREF: deblock+113j
		cmp	al, 2
		jnz	deblock25
		mov	cl, blk$off
		call	lru_ckdirty	; Returns Carry	set if buffer dirty?
		jb	deblock25
		xor	al, al		; Clean. Just update BCB trk/sec
		call	deblock$io	; Read/write a sector and/or update the	current	BCB with its address
					; AL=0:	Update BCB
					; AL=1:	Read and update
					; AL=2:	Write and update
		jmps	deblock4
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

deblock2b:				; CODE XREF: deblock+CAj
		cmp	al, 2
		jnz	deblock45
		mov	cl, blk$off
		push	bx
		call	lru_ckdirty	; Returns Carry	set if buffer dirty?
		pop	bx
		jmps	deblock45
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

deblock25:				; CODE XREF: deblock+B9j deblock+118j
					; ...
		mov	bx, curbcba
		mov	byte ptr [bx], 0FFh
		mov	al, 2
		call	deblock$io	; Read/write a sector and/or update the	current	BCB with its address
					; AL=0:	Update BCB
					; AL=1:	Read and update
					; AL=2:	Write and update

deblock4:				; CODE XREF: deblock+128j
		call	set$arecord
		call	move		; Copy CL bytes	from DX	to BX
		mov	byte ptr [di], 0

deblock45:				; CODE XREF: deblock+12Cj deblock+137j
		xor	al, al
		mov	ah, phy$off
		shr	ax, 1
		mov	si, word ptr fs_buffer+2
		add	si, ax
		mov	al, deblock_command
		cmp	al, 3
		jnz	deblock6
		mov	buffa, si
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

deblock6:				; CODE XREF: deblock+161j
		mov	cx, 40h
		mov	di, userdma
		cmp	al, 1
		mov	ax, userdmaseg
		mov	dx, word ptr fs_buffer
		push	ds
		push	es
		jz	deblock7
		mov	byte ptr 4[bx], 0FFh
		xchg	di, si
		xchg	ax, dx

deblock7:				; CODE XREF: deblock+17Aj
		mov	ds, dx
		mov	es, ax
		rep movsw
		pop	es
		pop	ds
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set$arecord:		; CODE XREF: get$bcba+58p deblock+BBp
					; ...
		mov	bx, curbcba
		mov	dx, offset bcb_drive
		mov	cl, 4

read$dir_ret:				; CODE XREF: read$dir+8j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

read$dir:		; CODE XREF: read$subdir+28p
					; cpm_login+48p ...
		call	r$dir
		test	relog, 0FFh	; Inlined r$dir1
		jz	read$dir_ret
		call	chk$exit$fxs
		call	tst$relog



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

rd$dir:		; CODE XREF: r$dir+2Ep
		mov	ax, dcnt
		mov	cl, 2
		shr	ax, cl
		mov	drec, ax
		mov	bcb_record, ax
		mov	bcb_record_h, 0
		mov	ah, 3
		jmp	wrdir0



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

read$subdir:		; CODE XREF: rd$parentdir+35p
					; rd$parentdir+67j ...
		mov	bx, cur_drvdir
		or	bx, bx
		jz	read$subdir2
		mov	si, lsn$add
		mov	al, 2[si]
		cmp	al, 1[bx]
		jz	read$subdir1
		mov	1[bx],	al
		mov	word ptr 6[bx], 0

read$subdir1:				; CODE XREF: read$subdir+12j
		test	word ptr 6[bx], 0FFFFh
		jz	read$subdir2
		call	rd$subdir1
		jmps	read$subdir3
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

read$subdir2:				; CODE XREF: read$subdir+6j
					; read$subdir+21j
		call	read$dir

read$subdir3:				; CODE XREF: read$subdir+26j
		call	end$of$dir
		jnz	read$subdir4
		xor	ax, ax
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

read$subdir4:				; CODE XREF: read$subdir+2Ej
		call	getdptra
		mov	ax, bx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

rd$subdir1:		; CODE XREF: read$subdir+23p
		mov	dx, dcnt
		inc	dx
		mov	dcnt, dx
		mov	ax, dname_cluster
		or	ax, ax
		jnz	rd$subdir2
		mov	ax, 20h
		mul	dx
		div	dpb_clustersize
		mov	dx, ax
		mov	ax, 6[bx]
		jmps	rd$subdir3
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

rd$subdir2:				; CODE XREF: rd$subdir1+Ej
		and	dx, names_per_block
		or	dx, dx
		jnz	rd$subdir4
		mov	dx, 1

rd$subdir3:				; CODE XREF: rd$subdir1+1Ej
					; rd$subdir1+39j
		or	dx, dx
		jz	rd$subdir4
		dec	dx
		push	dx
		call	fat_set_eof	; If FAT entry AX is unused, set it to EOF
		pop	dx
		cmp	ax, dpb_clusters
		jb	rd$subdir3
		jmp	set$end$dir
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

rd$subdir4:				; CODE XREF: rd$subdir1+26j
					; rd$subdir1+2Dj
		mov	dname_cluster, ax
		mov	dl, byte ptr dcnt
		and	dl, 3
		mov	cl, 5
		shl	dl, cl
		mov	dptr, dl
		mov	dh, dir_check_flag
		or	dh, dh
		jnz	rd$subdir5
		or	dl, dl
		jnz	rd$subdir6

rd$subdir5:				; CODE XREF: rd$subdir1+56j
		push	dx
		mov	bx, dcnt
		and	bx, names_per_block
		mov	cl, 5
		shl	bx, cl
		call	clus_to_sec
		mov	ah, 3
		call	wrdir0
		pop	dx
		test	dh, 0F0h
		jz	rd$subdir6
		call	rd$parentdir

rd$subdir6:				; CODE XREF: rd$subdir1+5Aj
					; rd$subdir1+75j ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

rd$parentdir:		; CODE XREF: rd$subdir1+77p
		mov	dname_cluster, 0
		mov	bx, cur_drvdir
		mov	ax, 2[bx]	; Parent dir
		cmp	ax, 6[bx]	; This dir
		jz	rd$subdir6
		push	dcnt
		push	word ptr 6[bx]	; Cluster of this dir
		push	bx		; Structure
		or	ax, ax
		jnz	rd$parentdir1
		mov	cur_drvdir, 0
		jmps	rd$parentdir2
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

rd$parentdir1:				; CODE XREF: rd$parentdir+1Cj
		mov	6[bx],	ax	; CWD is now parent

rd$parentdir2:				; CODE XREF: rd$parentdir+24j
		mov	ax, 4[bx]	; Dir entry number in previous parent
		dec	ax
		mov	dcnt, ax
		mov	dir_check_flag,	0F0h
		call	read$subdir
		pop	si
		mov	cur_drvdir, si
		pop	ax
		mov	6[si],	ax	; Cluster of CWD
		pop	dcnt
		dec	dcnt
		mov	dname_cluster, 0
		or	bx, bx
		jz	rd$parentdir3
		test	byte ptr 11[bx], 10h
		jz	rd$parentdir3
		cmp	ax, 26[bx]
		jz	rd$parentdir4

rd$parentdir3:				; CODE XREF: rd$parentdir+51j
					; rd$parentdir+57j
		call	media$change
		call	chk$exit$fxs
		jmp	tst$relog
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

rd$parentdir4:				; CODE XREF: rd$parentdir+5Cj
		jmp	read$subdir



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

seek$copy:		; CODE XREF: delete11+1Dp copy$dir0+9j
					; ...
		call	check$write
		mov	ah, 5
		call	wrdir0
		cmp	F_isfatfs, 0
		jz	wr_root_dirent
		mov	bx, cur_drvdir	; No CWD?
		or	bx, bx
		jz	wr_root_dirent
		cmp	word ptr 6[bx], 0; Or CWD is root?
		jz	wr_root_dirent
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

wr_root_dirent:				; CODE XREF: seek$copy+Dj seek$copy+15j
					; ...
		mov	cl, 0FDh
		jmp	checksum


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

wrdir0:					; CODE XREF: rd$dir+14j rd$subdir1+6Ep
					; ...
		call	deblock

setdata:				; CODE XREF: bdos:2C5Ap bdos:3D22p
					; ...
		mov	ax, userdmaseg
		mov	word ptr fs_buffer, ax
		mov	ax, userdma
		mov	word ptr fs_buffer+2, ax
		retn	

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

r$dir:		; CODE XREF: read$dirp	check$media+19p
		mov	dx, dpb_drm
		mov	bx, dcnt
		inc	bx
		mov	dcnt, bx
		sub	dx, bx
		jnb	read$dir0
		jmp	set$end$dir
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

read$dir0:				; CODE XREF: r$dir+Fj
		mov	al, byte ptr dcnt
		and	al, 3		; low(dcnt) and	dskmsk
		push	cx
		mov	cl, 5
		shl	al, cl		; Multiply by FCB size
		pop	cx
		mov	dptr, al
		test	dir_check_flag,	0FFh
		jnz	read$dir2
		or	al, al		; Return if not	a new record
		jnz	read_dir_ret

read$dir2:				; CODE XREF: r$dir+27j
		push	cx
		call	rd$dir
		pop	cx
		test	relog, 0FFh
		jnz	read_dir_ret

checksum:				; CODE XREF: seek$copy+20j
		mov	dx, drec
		mov	bx, dpb_cks
		and	bh, 7Fh		; Mask off fixed disk bit
		sub	dx, bx
		jnb	read_dir_ret	; Skip if > CSV	size
		push	cx
		call	compute$cs	; Compute checksum for current directory buffer
		mov	bx, drec
		add	bx, dph_csv
		pop	cx
		inc	cl
		jz	initial$cs
		inc	cl
		inc	cl
		jz	update$cs
		cmp	al, [bx]
		jz	read_dir_ret
		call	nowrite		; Return true if drive is software R/O
		jnz	read_dir_ret



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

media$change:		; CODE XREF: rdbuff+31p rd$parentdir+5Ep
		mov	bx, dph_dtabcb
		call	discard$data	; Called with BX->BCB chain head. Release all BCBs for a drive
		mov	al, 0FFh
		mov	relog, al
		mov	hashl, al
		mov	bx, offset removable_drive
		call	set$cdisk
		jmp	reset37x



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

initial$cs:		; CODE XREF: r$dir+57j
		cmp	al, [bx]
		mov	[bx], al
		jz	read_dir_ret
		mov	bx, lsn$add
		or	byte ptr 2[bx], 1

read_dir_ret:				; CODE XREF: r$dir+2Bj	r$dir+37j
					; ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

update$cs:		; CODE XREF: r$dir+5Dj
		mov	[bx], al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

getallocbit:		; CODE XREF: set$alloc$bit+1p
					; get$block+Dp	...
		mov	bx, cx
		and	cl, 7
		inc	cl
		mov	ch, cl
		mov	cl, 3
		shr	bx, cl
		add	bx, dph_alv
		mov	al, [bx]
		mov	cl, ch
		rol	al, cl
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set$alloc$bit:		; CODE XREF: scandm$a+3Fp
		push	dx
		call	getallocbit
		and	al, 0FEh
		pop	dx
		or	al, dl

rotr:					; CODE XREF: get$block+2Cp
		ror	al, cl
		mov	[bx], al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Return ALV size in bytes

get$nalbs:		; CODE XREF: copy$alv+8p scandm$ab+6p
					; ...
		mov	bx, dpb_dsm
		mov	cl, 3
		shr	bx, cl
		inc	bx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

copy$alv:		; CODE XREF: cpm_login+52j
					; DRV_FLUSH+31p ...
		cmp	F_isfatfs, 0
		jnz	dont_copy_alv
		pushf	
		call	get$nalbs	; Return ALV size in bytes
		mov	si, dph_alv
		mov	di, si
		add	di, bx
		mov	cx, bx
		push	cs
		call	f_interrupt	; Z should still be set from above
		jz	do_copy_alv
		xchg	si, di

do_copy_alv:				; CODE XREF: copy$alv+19j
		rep movsb

dont_copy_alv:				; CODE XREF: copy$alv+5j
		call	lru_free	; Free all LRU buffers for drive bcb_drive

scandm_ret:				; CODE XREF: scandm$a+10j
		retn	


;
; Set/Reset first ALV
;

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

scandm$a:		; CODE XREF: scandm$ab+1p scandm$ab+13p
					; ...
		call	getdptra
		add	bx, 10h
		push	cx
		mov	cl, 11h

scandm0:				; CODE XREF: scandm$a+45j
		pop	dx
		dec	cl
		jnz	scandm0a
		or	dl, dl
		jnz	scandm_ret
		mov	bx, dph_alv
		mov	ax, dpb_al0_al1
		or	[bx], ax
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

scandm0a:				; CODE XREF: scandm$a+Cj
		push	dx
		cmp	single,	0	; Nonzero if using 8-bit blocks
		jz	scandm1
		push	cx
		push	bx
		mov	cl, [bx]
		mov	ch, 0
		jmps	scandm2
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

scandm1:				; CODE XREF: scandm$a+22j
		dec	cl
		push	cx
		mov	cx, [bx]
		inc	bx
		push	bx

scandm2:				; CODE XREF: scandm$a+2Aj
		or	cx, cx
		jz	scandm3
		mov	bx, dpb_dsm
		cmp	bx, cx
		jb	scandm3
		call	set$alloc$bit

scandm3:				; CODE XREF: scandm$a+35j scandm$a+3Dj
		pop	bx
		inc	bx
		pop	cx
		jmps	scandm0



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

scandm$ab:		; CODE XREF: delete11+28p F_TRUNCATE+70p
					; ...
		push	cx
		call	scandm$a
		pop	cx

scandm$b:				; CODE XREF: close$fcb+A0p
		push	cx
		call	get$nalbs	; Return ALV size in bytes
		pop	cx
		mov	ax, dph_alv
		push	ax
		add	ax, bx
		mov	dph_alv, ax
		call	scandm$a
		pop	dph_alv
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

cpm_login:		; CODE XREF: curselect+15p
		cmp	dpb_cks, 8000h
		jnz	cpm_loginfixed
		mov	bx, lsn$add
		test	byte ptr 2[bx], 0FFh
		jnz	initial2a

cpm_loginfixed:				; CODE XREF: cpm_login+6j
		mov	bx, dph_dtabcb
		call	discard$data	; Called with BX->BCB chain head. Release all BCBs for a drive
		call	discard$dir	; Release all directory	BCBs for a drive
		call	get$nalbs	; Return ALV size in bytes
		mov	cx, bx
		mov	di, dph_alv
		mov	ax, dpb_al0_al1
		stosw			; Reserve directory blocks
		dec	cx
		dec	cx
		xor	ax, ax
		rep stosb		; Rest of ALV to zero
		mov	bx, lsn$add
		mov	[bx], al
		mov	1[bx],	al	; Home the disk
		mov	bcb_dirty, ax
		mov	bx, cdrmaxa
		mov	word ptr [bx], 4
		call	set$end$dir

initial2:				; CODE XREF: cpm_login+5Fj
					; cpm_login+63j ...
		mov	cl, 0FFh
		call	read$dir
		call	end$of$dir
		jnz	initial2b
		xor	al, al

initial2a:				; CODE XREF: cpm_login+10j
		jmp	copy$alv
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

initial2b:				; CODE XREF: cpm_login+4Ej
		call	fix$hash
		call	getdptra
		mov	al, [bx]
		cmp	al, 21h		; Skip date/time records
		jz	initial2
		cmp	al, 0E5h	; Skip deleted files
		jz	initial2
		cmp	al, 20h		; Skip labels
		jz	drv$lbl
		test	al, 10h
		jnz	initial3
		mov	cl, 1		; Scan for allocated blocks
		call	scandm$a

initial3:				; CODE XREF: cpm_login+6Bj
					; cpm_login+80j
		call	setcdr
		jmps	initial2
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

drv$lbl:				; CODE XREF: cpm_login+67j
		mov	al, 12[bx]
		mov	bx, lsn$add
		mov	[bx], al
		jmps	initial3



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_login:		; CODE XREF: curselect+1Ap
		cmp	dpb_cks, 8000h
		jnz	fat_log_hd
		mov	bx, lsn$add
		test	byte ptr 2[bx], 0FFh
		jnz	fat_initial2a

fat_log_hd:				; CODE XREF: fat_login+6j
		mov	bx, dph_dtabcb
		call	discard$data	; Called with BX->BCB chain head. Release all BCBs for a drive
		call	discard$dir	; Release all directory	BCBs for a drive
		xor	al, al
		mov	bx, lsn$add
		mov	[bx], al
		mov	1[bx],	al
		mov	bx, cdrmaxa
		mov	word ptr [bx], 4
		call	set$end$dir

fat_initial2:				; CODE XREF: fat_login+46j
					; fat_login+4Aj ...
		mov	cl, 0FFh
		call	read$dir
		call	end$of$dir
		jnz	fat_initial3
		xor	al, al

fat_initial2a:				; CODE XREF: fat_login+10j
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_initial3:				; CODE XREF: fat_login+3Aj
		call	getdptra
		mov	al, [bx]
		or	al, al		; End of dir
		jz	fat_initial2
		cmp	al, 0E5h	; Deleted
		jz	fat_initial2
		call	setcdr
		jmps	fat_initial2


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

copy$dir$loc:				; CODE XREF: delete10+2j bdos:47FCj
					; ...
		mov	al, dirloc
		jmp	sta$ret

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

chk$wild_cpm:		; CODE XREF: set$hash+2Dp cpm_delete+2Ap
					; ...
		xor	dl, dl



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

check$wild0:		; CODE XREF: valid_dl_f_fcb+3p
					; bdos:47B1p ...
		mov	cx, 0Bh
		mov	si, bx
		inc	si

chk_fcb_char:				; CODE XREF: check$wild0+19j
		lodsb
		and	al, 7Fh
		cmp	al, '?'
		jz	set$hashret
		or	dl, dl
		jz	chk_fcb_dl0
		cmp	al, '['
		jz	set$hashret
		cmp	al, ']'
		jz	set$hashret

chk_fcb_dl0:				; CODE XREF: check$wild0+Fj
		loop	chk_fcb_char
		or	al, 1

set$hashret:				; CODE XREF: check$wild0+Bj
					; check$wild0+13j ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

check$wild:		; CODE XREF: F_OPEN+29p bdos:4790p
					; ...
		xor	dl, dl



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

valid_dl_f_fcb:		; CODE XREF: F_MAKE+10p
		mov	bx, offset user_fcb
		call	check$wild0
		jnz	set$hashret
		mov	ah, 9
		jmp	disk_error



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set$hash:		; CODE XREF: searchi+10p
		cmp	dph_hash, 0
		jz	set$hashret
		or	cl, cl
		jz	set$hashret
		cmp	cl, 0Ch
		jb	set$hash2
		mov	al, 2
		jz	set$hash1
		mov	al, 3

set$hash1:				; CODE XREF: set$hash+12j
		mov	hashl, al
		mov	al, fs_function
		cmp	al, 3
		jz	get$hash
		cmp	al, 11h
		jz	set$hash15
		cmp	al, 7
		jnb	get$hash

set$hash15:				; CODE XREF: set$hash+22j
		mov	hashl, 2
		call	chk$wild_cpm
		jnz	get$hash

set$hash2:				; CODE XREF: set$hash+Ej
		mov	hashl, 0



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get$hash:		; CODE XREF: set$hash+1Ej set$hash+26j
					; ...
		mov	si, bx
		lodsb
		mov	hash, al
		xor	bx, bx
		and	al, 20h
		jz	get$hash0
		or	hash, 10h
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

get$hash0:				; CODE XREF: get$hash+Aj
		mov	dl, al
		mov	cx, 0Bh

get$hash1:				; CODE XREF: get$hash+40j
		cmp	cl, 6
		jz	get$hash3
		cmp	cl, 4
		jz	get$hash3
		shl	bx, 1
		rcl	dl, 1
		test	cl, 1
		jnz	get$hash3
		shl	bx, 1
		rcl	dl, 1

get$hash3:				; CODE XREF: get$hash+1Aj get$hash+1Fj
					; ...
		lodsb
		and	al, 7Fh
		sub	al, 20h
		ror	al, 1
		jnb	get$hash4
		rol	al, 1

get$hash4:				; CODE XREF: get$hash+35j
		xor	ah, ah
		add	bx, ax
		adc	dl, 0
		loop	get$hash1
		mov	word ptr hash+1, bx
		mov	bx, offset hash
		and	dl, 3
		ror	dl, 1
		ror	dl, 1
		or	[bx], dl
		lodsb
		and	al, 1Fh
		inc	si
		mov	ah, [si]
		and	ah, 3Fh
		mov	cl, 3
		shl	al, cl
		shr	ax, cl
		mov	dl, dpb_exm
		shl	ax, 1

get$hash5:				; CODE XREF: get$hash+6Bj
		shr	ax, 1
		shr	dl, 1
		jb	get$hash5
		and	ah, 1
		ror	ah, cl
		or	[bx], ah
		mov	3[bx],	al

get$hashret:				; CODE XREF: search$hash+5j
					; search$hash+Cj ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

search$hash:		; CODE XREF: searchn+5p
		cmp	dph_hash, 0
		jz	get$hashret
		mov	al, searchl
		or	al, al
		jz	get$hashret
		cmp	hashl, 0FFh
		jz	get$hashret
		mov	bx, cdrmaxa
		mov	cx, [bx]
		dec	al
		jnz	search$h0
		mov	cx, dpb_drm

search$h0:				; CODE XREF: search$hash+1Dj
		mov	bx, dcnt
		sub	cx, bx
		jz	get$hashret
		mov	es, dph_hash

		inc	bx
		mov	di, bx
		shl	di, 1
		shl	di, 1
		sub	di, 4
		call	search$h_sub
		mov	ax, ds
		mov	es, ax

		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

search$h_sub:		; CODE XREF: search$hash+39p
					; search$h_sub+16j
		add	di, 4
		mov	si, offset hash
		lodsb
		xor	al, es:[di]
		mov	dl, al
		and	al, 1Fh
		jnz	search$h2b
		call	search$h6
		jz	search$h2g

search$h2:				; CODE XREF: search$h_sub+39j
					; search$h_sub+3Fj ...
		inc	bx
		loop	search$h_sub
		cmp	dcnt, 0FFFFh
		jnz	search$h2a
		mov	ax, ds
		mov	es, ax
		call	tst$log$fxs
		jnz	search$h2a
		mov	hashl, 0FFh

search$h2a:				; CODE XREF: search$h_sub+1Dj
					; search$h_sub+26j
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

search$h2b:				; CODE XREF: search$h_sub+Ej
		mov	al, byte ptr xdcnt+1
		inc	al
		jnz	search$h2c
		cmp	es:byte ptr [di], 0F5h
		jnz	search$h2
		jmps	search$h2d
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

search$h2c:				; CODE XREF: search$h_sub+33j
		inc	al
		jnz	search$h2
		call	search$h6
		jnz	search$h2
		mov	al, find$xfcb
		inc	al
		jnz	search$h2e
		test	es:byte ptr [di], 10h
		jz	search$h2
		test	dl, 0Fh
		jnz	search$h2

search$h2d:				; CODE XREF: search$h_sub+3Bj
		mov	xdcnt, bx
		jmps	search$h2
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

search$h2e:				; CODE XREF: search$h_sub+4Bj
		inc	al
		jnz	search$h2f
		test	dl, 0Fh
		jnz	search$h2
		jmps	search$h2g
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

search$h2f:				; CODE XREF: search$h_sub+60j
		test	es:byte ptr [di], 1Fh
		jnz	search$h2

search$h2g:				; CODE XREF: search$h_sub+13j
					; search$h_sub+67j
		mov	dx, dcnt
		dec	bx
		mov	dcnt, bx
		mov	al, bl
		and	al, 3
		cmp	al, 3
		jz	search$hret
		and	bl, 0FCh
		and	dl, 0FCh
		cmp	bx, dx
		jz	search$hret
		or	dir_check_flag,	0Fh
		xor	al, al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

search$h6:		; CODE XREF: search$h_sub+10p
					; search$h_sub+41p
		mov	al, hashl
		or	al, al
		jz	search$hret
		mov	ah, 0E0h
		cmp	al, 3
		jz	search$h6a
		mov	ah, 0C0h

search$h6a:				; CODE XREF: search$h6+Bj
		test	dl, ah
		jnz	search$hret
		xor	ah, ah
		xchg	ax, cx
		push	di
		inc	di
		rep cmpsb
		xchg	ax, cx
		pop	di

search$hret:				; CODE XREF: search$h_sub+7Ej
					; search$h_sub+88j ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fix$hash:		; CODE XREF: cpm_login+55p
					; delete11+2Bp	...
		cmp	dph_hash, 0
		jz	search$hret
		push	word ptr hash
		push	word ptr hash+2
		call	getdptra
		call	get$hash
		mov	ax, dcnt
		shl	ax, 1
		shl	ax, 1
		mov	di, ax
		mov	es, dph_hash

		mov	si, offset hash
		mov	cx, 2
		rep movsw
		mov	ax, ds
		mov	es, ax

		pop	word ptr hash+2
		pop	word ptr hash
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

save$dcnt$pos1:		; CODE XREF: searchn+34p searchn+56p
		cmp	byte ptr xdcnt+1, 0FFh
		jnz	search$hret



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

save$dcnt$pos0:		; CODE XREF: bdos:3716p bdos:3737p
					; ...
		mov	ax, dcnt
		mov	xdcnt, ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

searchi:		; CODE XREF: search$extnum+2p
					; restore_dir_fcb+5p
					; ...
		mov	bx, offset user_fcb
		mov	searcha, bx

searchi1:				; CODE XREF: does$xfcb$exist+18p
					; bdos:47BAp
		mov	dirloc,	0FFh
		mov	searchl, cl
		call	set$hash
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Find the first extent	of a file

find_extent_0:		; CODE XREF: update$stamp+16p
					; F_TIMEDATE+10p ...
		xor	ax, ax
		mov	user_fcb+0Ch, al
		mov	user_fcb+0Eh, al



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Find a numbered extent

search$namlen:		; CODE XREF: openp close$fcb+Cp
					; ...
		mov	cl, 0Fh
		jmps	search



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Find any extent of a file

search$extnum:		; CODE XREF: cpm_delete+8p
					; cpm_delete+47p ...
		mov	cl, 0Ch

search:					; CODE XREF: search$namlen+2j
					; F_SFIRST+4Ap	...
		call	searchi

search1:				; CODE XREF: bdos:47BDp
		call	set$end$dir	; Entry	point used by rename



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Search for the next directory	element,
; assuming a previous call on search

searchn:		; CODE XREF: searchn+4Fj bdos:3719j
					; ...
		mov	user0$pass, 0	; Don't try user 0 yet
		call	search$hash
		jnz	search$fin
		mov	cl, 0
		call	read$dir	; Read next dir	element
		call	end$of$dir
		jz	search$fin
		mov	dx, searcha	; Not end of dir, scan for match
		mov	si, dx
		lodsb
		cmp	al, 0E5h
		jz	searchnext	; Keep scanning	if empty
		push	dx		; Not empty, may be end	of logical directory
		call	compcdr		; Past logical end?
		pop	dx
		jnb	search$fin	; Artificial stop

searchnext:				; CODE XREF: searchn+1Dj
		call	getdptra	; BX = buffa + dptr
		mov	cl, searchl	; CL = length of search
		xor	ch, ch		; CH counts up,	CL counts down
		cmp	byte ptr [bx], 0E5h
		jnz	srchnxt1
		call	save$dcnt$pos1

srchnxt1:				; CODE XREF: searchn+32j
		mov	save$xfcb, 0
		mov	al, [bx]
		and	al, 0EFh	; Is this an XFCB?
		cmp	al, [bx]
		jz	search$loop
		mov	si, dx
		cmp	al, [si]
		jnz	search$loop
		mov	al, find$xfcb
		or	al, al
		jz	searchn		; Search for the next directory	element,
					; assuming a previous call on search
		mov	save$xfcb, al
		jmps	searchok
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

search$fin:				; CODE XREF: searchn+8j searchn+12j
					; ...
		call	save$dcnt$pos1
		call	set$end$dir



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

lret$eq$ff:		; CODE XREF: chk$exit$fxs+17j
					; rdbuff+56p ...
		mov	al, 0FFh
		mov	ch, al
		inc	ch
		jmp	sta$ret


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

search$loop:				; CODE XREF: searchn+42j searchn+48j
					; ...
		or	cl, cl
		jz	endsearch
		mov	si, dx
		lodsb
		cmp	ch, 0Eh
		jnz	not_modnum
		and	al, 3Fh		; Mask off high	2 bits
		jmps	was_modnum
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

not_modnum:				; CODE XREF: bdos:36E1j
		and	al, 7Fh
		cmp	al, '?'         ; "?" in user FCB matches all
		jz	searchok
		cmp	ch, 0Dh		; If S1, continue
		jz	searchok
		cmp	ch, 0Ch		; Extent?
		jz	searchext

was_modnum:				; CODE XREF: bdos:36E5j
		sub	al, [bx]
		and	al, 7Fh		; Mask out flags/extent	modulus
		jnz	searchnm	; Skip if not matched
		jmps	searchok
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

searchext:				; CODE XREF: bdos:36F5j
		push	cx
		mov	cl, [bx]
		call	compext		; Compare extent nos in	AL and CL
					; Return nonzero if they do not	match
		pop	cx
		jnz	j_searchn	; No match
		test	user0$pass, 0FFh
		jz	disable_user0
;
; inlined save$dcnt$pos2
;
		inc	bx
		inc	bx
		cmp	byte ptr [bx], 0
		jnz	j_searchn
		call	save$dcnt$pos0
		jmp	searchn		; Search for the next directory	element,
					; assuming a previous call on search
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ
;
; Disable search of user 0 if any fcb is found under
; the current user number
;

disable_user0:				; CODE XREF: bdos:370Dj
		mov	search$user0, 0

searchok:				; CODE XREF: searchn+54j bdos:36EBj
					; ...
		inc	dx
		inc	bx
		inc	ch
		dec	cl
		jmps	search$loop
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ
;
; Entire name matches, return dir position
;

endsearch:				; CODE XREF: bdos:36D9j
		cmp	save$xfcb, 0FFh
		jnz	endsearch1
		cmp	byte ptr xdcnt+1, 0FEh
		jnz	j_searchn
		call	save$dcnt$pos0

j_searchn:				; CODE XREF: bdos:3706j bdos:3714j
					; ...
		jmp	searchn		; Search for the next directory	element,
					; assuming a previous call on search
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

endsearch1:				; CODE XREF: bdos:372Ej
		xor	al, al
		mov	dirloc,	al
		mov	byte ptr aret, al
;
; Successful search - return with zero flag reset
;
		mov	ch, al
		inc	ch

endsearch_ret:				; CODE XREF: does$xfcb$exist+5j
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ
; Search no match routine

searchnm:				; CODE XREF: bdos:36FBj
		or	ch, [bx]
		jnz	j_searchn	; fcb(0)?
		test	search$user0, 0FFh
		jz	j_searchn	; dir fcb(0)=0?
		mov	user0$pass, 0FFh
		jmps	searchok

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

init_xfcb_srch:		; CODE XREF: bdos:47A5p bdos:47DCp
		mov	al, 0FFh



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

init_xfcb_srch1:		; CODE XREF: does$xfcb$exist+Cp
					; cpm_delete+5p
		mov	find$xfcb, al
		mov	al, 0FEh
		mov	byte ptr xdcnt+1, al

init_xfcbs_ret:				; CODE XREF: cpm_delete+Bj
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

does$xfcb$exist:		; CODE XREF: bdos:47D1p bdos:47F7p
		cmp	byte ptr xdcnt+1, 0FEh
		jz	endsearch_ret
		call	set_dcnt_dblk
		xor	al, al
		call	init_xfcb_srch1
		mov	bx, searcha
		or	byte ptr [bx], 10h
		mov	cl, 0Ch
		call	searchi1
		jmp	searchn		; Search for the next directory	element,
			; assuming a previous call on search


;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

xdcnt_eq_dcnt:		; CODE XREF: openx+42p	openx+62p
					; ...
		mov	ax, dcnt
		mov	xdcnt, ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

restore_dir_fcb:		; CODE XREF: openx+4Ap	openx+87p
					; ...
		call	set_dcnt_dblk
		mov	cl, 0Fh
		call	searchi
		jmp	searchn		; Search for the next directory	element,
			; assuming a previous call on search


;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

cpm_delete:		; CODE XREF: F_DELETE+1Bj
		call	get$atts

deletex:				; CODE XREF: cpm_delete+40j
		mov	al, 0FEh	; Make search return matching
					; fcbs and xfcbs
		call	init_xfcb_srch1
		call	search$extnum	; Find any extent of a file
		jz	init_xfcbs_ret

delete00:				; CODE XREF: cpm_delete+45j
		call	getdptra
		mov	al, [bx]
		and	al, 10h		; Is it	an xfcb?
		jnz	delete01	; yes
		test	attributes, 80h	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		jnz	delete00a
		call	check$rodir

delete00a:				; CODE XREF: cpm_delete+1Bj
		call	get$dir$mode
		rol	al, 1		; Delete requires password?
		jb	delete02	; No
		mov	bx, offset user_fcb
		call	chk$wild_cpm	; Is this a wildcard delete?
		jz	delete02
;
; Not wild and passwords inactive
; Skip to pass 2
;
		jmps	delete11
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ
;
; Check	XFCB password if passwords enabled
;

delete01:				; CODE XREF: cpm_delete+14j
		call	get$dir$mode
		rol	al, 1
		jnb	delete02
		call	chk_xfcb_passwd
		jz	delete02
		call	chk$pw$error
		jmps	deletex
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

delete02:				; CODE XREF: cpm_delete+25j
					; cpm_delete+2Dj ...
		call	searchn		; Search for the next directory	element,
					; assuming a previous call on search
		jnz	delete00
		call	search$extnum	; Find any extent of a file



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

delete10:		; CODE XREF: delete11+31j F_MAKE+ABp
		jnz	delete11
		jmp	copy$dir$loc



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

delete11:		; CODE XREF: cpm_delete+2Fj
					; delete10j ...
		call	getdptra
		mov	al, [bx]	; Is addressed dir fcb an xfcb?
		and	al, 10h
		jnz	delete12
		test	attributes, 80h	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		jnz	delete13

delete12:				; CODE XREF: delete11+7j
		mov	byte ptr [bx], 0E5h; Delete dir	FCB or XFCB

delete13:				; CODE XREF: delete11+Ej
		pushf	
		call	get$dtba$8	; Does SFCB exist?
		or	al, al
		jnz	delete13a
		mov	[bx], al	; If so, zero its mode byte

delete13a:				; CODE XREF: delete11+19j
		call	seek$copy
		push	cs
		call	f_interrupt
		jnz	delete13b
		mov	cl, 0
		call	scandm$ab

delete13b:				; CODE XREF: delete11+24j
		call	fix$hash
		call	searchn		; Search for the next directory	element,
					; assuming a previous call on search
		jmps	delete10


;
; Given	allocation vector position CX, find the	closest	zero bit
; by searching left and	right. If found, set the bit to	1 and 
; return the bit position in BX. If not	found return BX=0
;
;

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get$block:		; CODE XREF: cpm_writerec+5Fp
		mov	dx, cx

righttst:				; CODE XREF: get$block+18j
					; get$block+26j
		cmp	dx, dpb_dsm
		jnb	retblock0
		inc	dx
		push	cx
		push	dx
		mov	cx, dx
		call	getallocbit
		rcr	al, 1
		jnb	retblock
		pop	dx
		pop	cx

lefttst:				; CODE XREF: get$block+44j
		or	cx, cx
		jz	righttst
		dec	cx
		push	dx
		push	cx
		call	getallocbit
		rcr	al, 1
		jnb	retblock
		pop	cx
		pop	dx
		jmps	righttst
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

retblock:				; CODE XREF: get$block+12j
					; get$block+22j
		rcl	al, 1
		inc	al
		call	rotr
		mov	cl, curdsk
		mov	bx, offset proc_using_drvs
		push	ds
		mov	ds, rlr
		call	set$cdisk1
		pop	ds
		pop	bx
		pop	dx
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

retblock0:				; CODE XREF: get$block+6j
		or	cx, cx
		jnz	lefttst
		mov	bx, cx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

copy$dir2:		; CODE XREF: copy$dir0p F_ATTRIB+27p
		push	dx
		mov	ch, 0
		mov	dx, offset user_fcb
		add	dx, cx
		call	getdptra
		pop	cx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Copy FCB information starting	at CL for DL bytes
; into the currently addressed directory entry

copy$dir:		; CODE XREF: bdos:47ECp
		mov	dh, 80h



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

copy$dir0:		; CODE XREF: make+59p
		call	copy$dir2
		inc	cl

copy$dir1:				; CODE XREF: copy$dir0+1Bj
		dec	cl
		jnz	copy$dir1a
		jmp	seek$copy
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

copy$dir1a:				; CODE XREF: copy$dir0+7j
		mov	ah, [bx]
		and	ah, ch
		mov	si, dx
		lodsb
		and	al, 7Fh
		or	al, ah
		mov	[bx], al
		inc	bx
		inc	dx
		jmps	copy$dir1



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

copy$user$no:		; CODE XREF: bdos:47A8p bdos:47D9p
					; ...
		mov	al, user_fcb
		mov	bx, offset user_fcb+10h
		mov	[bx], al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

open:		; CODE XREF: cpm_rwrand+89p
					; F_OPEN+3Dp ...
		call	search$namlen	; Find a numbered extent

open1:					; CODE XREF: F_OPEN+6Ap
		jz	set$rcret



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

open$copy:		; CODE XREF: open$reel+52p
		call	setfwf
		push	bx		; BX->S2
		dec	bx
		dec	bx		; BX->EX
		mov	ah, [bx]
		push	ax		; AH=EX	AL=S2
		call	getdptra
		mov	dx, bx
		mov	bx, offset user_fcb
		mov	cl, 20h
		call	move		; Copy CL bytes	from DX	to BX
		call	get$dir$ext	; Compute directory extent from	FCB
		mov	cl, al
		pop	ax		; Restore original EX and S2
		pop	bx
		mov	[bx], al
		dec	bx
		dec	bx
		mov	[bx], ah



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set$rc:		; CODE XREF: getfcb+12p close+27p
					; ...
		xor	ch, ch
		mov	si, offset user_fcb+0Fh
		mov	al, [bx]
		sub	al, cl
		jz	set$rc2
		mov	al, ch
		jnb	set$rc1
		mov	al, 80h
		or	al, [si]

set$rc1:				; CODE XREF: set$rc+Dj
		mov	[si], al

set$rcret:				; CODE XREF: open+3j set$rc+18j
					; ...
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

set$rc2:				; CODE XREF: set$rc+9j
		cmp	[si], al
		jnz	set$rcret

set$rc3:				; CODE XREF: close$fcb+86p
					; F_TRUNCATE+CDp ...
		xor	al, al
		mov	[si], al
		cmp	dminx, al
		jz	set$rcret
		mov	byte ptr [si], 80h
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

restore$rc:		; CODE XREF: close+20p	open$reel+9Cp
					; ...
		mov	al, user_fcb+0Fh
		cmp	al, 81h
		jb	restore$rc1
		and	al, 7Fh
		mov	user_fcb+0Fh, al

restore$rc1:				; CODE XREF: restore$rc+5j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

mergezero:		; CODE XREF: close$fcb+40p
					; close$fcb+45p
		cmp	word ptr [bx], 0
		jnz	mzero_ret
		mov	si, dx
		lodsw
		mov	[bx], ax

mzero_ret:				; CODE XREF: mergezero+3j close$fcb+Fj
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

close$fcb:		; CODE XREF: close+2Ap
		test	byte ptr dpb_cks+1, 80h
		jnz	close$fcb0
		mov	dir_check_flag,	0F0h

close$fcb0:				; CODE XREF: close$fcb+5j
		call	search$namlen	; Find a numbered extent
		jz	mzero_ret
		call	getdptra
		add	bx, 10h
		mov	dx, bx
		mov	bx, offset user_fcb+10h
		mov	cl, 10h

merge0:					; CODE XREF: close$fcb+5Aj
		cmp	single,	0	; Nonzero if using 8-bit blocks
		jz	merged
		mov	al, [bx]
		or	al, al
		mov	si, dx
		lodsb
		jnz	fcbnzero
		mov	[bx], al

fcbnzero:				; CODE XREF: close$fcb+2Cj
		or	al, al
		jnz	buffnzero
		mov	al, [bx]
		mov	di, dx
		cld	
		stosb

buffnzero:				; CODE XREF: close$fcb+32j
		cmp	al, [bx]
		jz	dmset
		jmps	mergerr
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

merged:					; CODE XREF: close$fcb+23j
		call	mergezero
		xchg	bx, dx
		call	mergezero
		xchg	bx, dx
		mov	si, dx
		mov	ax, [si]
		cmp	ax, [bx]
		jnz	mergerr
		inc	dx
		inc	bx
		dec	cl

dmset:					; CODE XREF: close$fcb+3Cj
		inc	dx
		inc	bx
		dec	cl
		jnz	merge0
		mov	bx, dx
		sub	bx, 14h
		push	bx
		call	get$dir$ext	; Compute directory extent from	FCB
		pop	si
		mov	cl, [si]
		mov	ch, [bx]
		mov	[si], al
		mov	[bx], al
		add	si, 3
		add	bx, 3
		cmp	al, cl
		jnz	mrg$rc1
		cmp	al, ch
		jnz	mrg$rc2
		mov	al, [si]
		cmp	al, [bx]
		jb	mrg$rc1
		or	al, al
		jnz	mrg$rc2
		call	set$rc3

mrg$rc1:				; CODE XREF: close$fcb+76j
					; close$fcb+80j
		xchg	bx, si

mrg$rc2:				; CODE XREF: close$fcb+7Aj
					; close$fcb+84j
		mov	al, [si]
		mov	[bx], al
		call	getdptra
		add	bx, 0Bh
		mov	al, [bx]
		and	al, 7Fh
		mov	[bx], al
		call	setfwf
		mov	cl, 1
		call	scandm$b
		jmp	seek$copy
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

mergerr:				; CODE XREF: close$fcb+3Ej
					; close$fcb+50j ...
		call	setfwf
		mov	word ptr 2[bx], 0FFFFh
		jmp	lret$eq$ff



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

close:		; CODE XREF: open$reel+19p
					; cpm_rwrand+64p ...
		xor	ax, ax
		mov	byte ptr aret, al
		call	nowrite		; Return true if drive is software R/O
		jnz	makeret
		mov	al, user_fcb+0Eh
		and	al, 80h
		jnz	makeret
		call	cp_fcb10_ffff
		jz	mergerr
		call	get$dir$ext	; Compute directory extent from	FCB
		mov	cl, al
		mov	ch, [bx]
		push	cx
		mov	[bx], al
		call	restore$rc
		cmp	cl, ch
		jnb	close1
		call	set$rc

close1:					; CODE XREF: close+25j
		call	close$fcb
		mov	bx, offset user_fcb+0Ch
		pop	cx
		mov	cl, [bx]
		mov	[bx], ch
		jmp	set$rc



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

make:		; CODE XREF: open$reel+4Bp
					; cpm_rwrand+9Ep ...
		cmp	xdcnt, 0FFFFh
		jz	cpm_make0
		call	set_dcnt_dblk

cpm_make0:				; CODE XREF: make+5j
		push	word ptr user_fcb
		mov	user_fcb, 0E5h
		mov	cl, 1
		call	searchi
		call	searchn		; Search for the next directory	element,
					; assuming a previous call on search
		pop	word ptr user_fcb
		jnz	make01

makeret:				; CODE XREF: close+8j close+Fj
					; ...
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

make01:					; CODE XREF: make+1Fj
		test	make$xfcb, 0FFh
		jnz	makeret
		mov	bx, offset user_fcb+0Dh
		mov	byte ptr [bx], 0
		inc	bx
		mov	al, [bx]
		push	ax
		push	bx
		and	byte ptr [bx], 3Fh
		inc	bx
		mov	cx, 11h
		mov	al, 1

make0:					; CODE XREF: make+41j make+4Fj
		mov	byte ptr [bx], 0
		inc	bx
		loop	make0
		dec	al
		jnz	make1
		call	get$dtba
		or	al, al
		mov	cx, 0Ah
		jz	make0

make1:					; CODE XREF: make+45j
		call	setcdr
		mov	cl, 0
		mov	dx, 20h
		call	copy$dir0
		pop	bx
		pop	ax
		mov	[bx], al
		mov	result_F0F, 0
		call	fix$hash
		jmp	setfwf



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

open$reel:		; CODE XREF: bdos:3D06p cpm_writerec+37p
		mov	al, user_fcb+0Eh
		mov	openreel_S2, al
		mov	bx, offset user_fcb+0Ch
		mov	al, [bx]
		mov	cl, al
		inc	cl
		call	compext		; Compare extent nos in	AL and CL
					; Return nonzero if they do not	match
		jnz	open$reel00
		jmp	open$reel3
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

open$reel00:				; CODE XREF: open$reel+12j
		push	bx
		push	cx
		call	close
		pop	cx
		pop	bx
		cmp	byte ptr aret, 0FFh
		jnz	open$reel01
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

open$reel01:				; CODE XREF: open$reel+23j
		mov	al, 1Fh
		and	al, cl		; Increment extent
		mov	[bx], al
		jnz	open$reel0
		add	bx, 2
		inc	byte ptr [bx]
		mov	al, [bx]	; Increment module
		and	al, 3Fh
		jz	open$r$error

open$reel0:				; CODE XREF: open$reel+2Cj
		mov	xdcnt, 0FFFFh
		call	search$namlen	; Find a numbered extent
		jnz	open$reel1
		mov	al, rmf		; Read mode flag
		inc	al
		jz	open$r$error
		call	make
		jz	open$r$error
		jmps	open$reel1a
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

open$reel1:				; CODE XREF: open$reel+42j
		call	open$copy

open$reel1a:				; CODE XREF: open$reel+50j
		call	set$lsn

open$reel2:				; CODE XREF: open$reel+A2j
		call	getfcb		; Set variables	from currently addressed FCB
		xor	al, al
		mov	vrecord, al
		jmp	sta$ret
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

open$r$error:				; CODE XREF: open$reel+37j
					; open$reel+49j ...
		mov	bx, offset user_fcb+0Ch
		mov	al, openreel_S2
		mov	2[bx],	al
		mov	al, [bx]
		dec	al
		and	al, 1Fh
		mov	[bx], al
		mov	open_unknown, 0FFh
		jmp	f_ret_1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

open$reel3:				; CODE XREF: open$reel+14j
		mov	[bx], cl
		call	get$dir$ext	; Compute directory extent from	FCB
		mov	cl, al
		test	high$ext, 80h
		jnz	open$reel4
		cmp	al, [bx]
		jnb	open$reel4
		dec	byte ptr [bx]
		cmp	rmf, 0FFh	; Read mode flag
		jnz	open$reel3a
		jmp	f_ret_1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

open$reel3a:				; CODE XREF: open$reel+95j
		inc	byte ptr [bx]

open$reel4:				; CODE XREF: open$reel+88j
					; open$reel+8Cj
		call	restore$rc
		call	set$rc
		jmps	open$reel2



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

calc_extent_no:		; CODE XREF: cpm_rwrand+1p
					; fat_rdwr+41p
		mov	al, user_fcb+21h
		mov	dl, al
		and	dl, 7Fh
		rcl	al, 1
		mov	al, user_fcb+22h
		mov	ch, al
		rcl	ch, 1
		and	ch, 1Fh
		and	al, 0F0h
		or	al, user_fcb+23h
		mov	cl, 4
		rol	al, cl
		mov	cl, ch
		mov	ch, al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; CL=-1	read  0	write

cpm_rwrand:		; CODE XREF: F_READRAND+11p
					; F_WRITERAND+11p ...
		push	cx
		call	calc_extent_no
		cmp	user_fcb+23h, 3
		mov	bl, 6
		jbe	crwr_1
		jmp	seekerr
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

crwr_1:					; CODE XREF: cpm_rwrand+Bj
		mov	user_fcb+20h, dl
		cmp	fs_function, 28	; Write	ZF?
		jz	diskwr11
		call	cp_fcb10_ffff
		jz	diskwr11
		mov	al, ch
		sub	al, user_fcb+0Eh
		and	al, 3Fh
		jnz	diskwr_err
		mov	al, user_fcb+0Ch
		cmp	al, cl
		jnz	fill0
		jmp	seekok2
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fill0:					; CODE XREF: cpm_rwrand+2Fj
		call	compext		; Compare extent nos in	AL and CL
					; Return nonzero if they do not	match
		jnz	diskwr_err
		push	cx
		call	get$dir$ext	; Compute directory extent from	FCB
		pop	cx
		cmp	al, cl
		jnb	fill2
		test	high$ext, 80h
		jnz	fill2
		pop	dx
		push	dx
		inc	dl
		jnz	fill2
		inc	dl
		pop	dx
		jmp	f_ret_1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fill2:					; CODE XREF: cpm_rwrand+40j
					; cpm_rwrand+47j ...
		mov	user_fcb+0Ch, cl
		mov	cl, al
		call	restore$rc
		call	set$rc
		jmps	seekok2
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

diskwr_err:				; CODE XREF: cpm_rwrand+28j
					; cpm_rwrand+37j
		push	cx
		call	close
		pop	cx
		mov	bl, 3
		mov	al, byte ptr aret
		inc	al
		jz	seekerr

diskwr11:				; CODE XREF: cpm_rwrand+19j
					; cpm_rwrand+1Ej
		mov	xdcnt, 0FFFFh
		xchg	cl, user_fcb+0Ch; CL = EX
		mov	al, user_fcb+0Eh; AL = S2
		xchg	ch, al		; CH = S2, CL =	EX
		push	cx
		and	ch, 40h
		or	al, ch
		mov	user_fcb+0Eh, al
		call	open
		mov	al, byte ptr aret
		inc	al
		jnz	seekok
		mov	bp, sp
		mov	cx, 2[bp]
		mov	bl, 4
		inc	cl
		jz	badseek
		call	make
		mov	bl, 5
		mov	al, byte ptr aret
		inc	al
		jz	badseek

seekok:					; CODE XREF: cpm_rwrand+91j
		pop	cx
		call	set$lsn

seekok2:				; CODE XREF: cpm_rwrand+31j
					; cpm_rwrand+61j
		pop	cx
		xor	al, al
		jmp	sta$ret
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

badseek:				; CODE XREF: cpm_rwrand+9Cj
					; cpm_rwrand+A8j
		pop	ax
		mov	user_fcb+0Ch, al
		mov	user_fcb+0Eh, ah

seekerr:				; CODE XREF: cpm_rwrand+Dj
					; cpm_rwrand+6Fj
		pop	cx
		mov	byte ptr aret, bl
		or	bl, bl
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

check$nprs:		; CODE XREF: bdos:3D18p cpm_writerec+E4p
		mov	ch, blk$off	; Is direct transfer operation in
					; progress?
		mov	al, dir$cnt
		cmp	al, 2
		jb	check$npr1	; No.
		dec	al
		mov	dir$cnt, al
		stc	
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

check$npr1:				; CODE XREF: check$nprs+9j
		mov	al, dpb_phm
		mov	cl, al
		and	al, ch
		jz	check$npr11	; Are we in mid-physical record?

check$npr1a:				; CODE XREF: check$nprs+2Ej
					; check$nprs+35j ...
		or	cl, cl
		jz	check$npr1b
		xor	al, al		; No deblocking	required
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

check$npr1b:				; CODE XREF: check$nprs+1Dj
		or	al, 1		; Deblocking required
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

check$npr11:				; CODE XREF: check$nprs+19j
		mov	dh, cl
		not	dh
		mov	al, last_sec_count
		cmp	al, 2
		jb	check$npr1a
		test	high$ext, 80h
		jnz	check$npr1a
		cmp	fs_function, 16h
		jz	check$npr1a
		mov	bx, offset vrecord
		mov	ah, [bx]
		add	al, ah
		cmp	al, 80h
		jb	check$npr2
		mov	al, 80h

check$npr2:				; CODE XREF: check$nprs+47j
		push	cx
		mov	byte ptr [bx], 7Fh
		push	bx
		push	ax
		mov	bl, al
		mov	al, dpb_blm
		mov	dl, al
		inc	dl
		not	al
		and	ah, al
		test	rmf, 0FFh	; Read mode flag
		jz	check$npr21
		mov	al, rcount
		and	al, dh
		cmp	al, bl
		jb	check$npr23

check$npr21:				; CODE XREF: check$nprs+63j
		mov	al, bl

check$npr23:				; CODE XREF: check$nprs+6Cj
		sub	al, ah
		cmp	al, dl
		jb	check$npr9
		push	ax
		call	dm$position
		mov	ch, al
		mov	al, dminx
		cmp	al, ch
		mov	dl, al
		jz	check$npr5
		mov	cl, al
		push	cx
		mov	ch, 0
		call	get$dm		; Get block CX from FCB; returns in BX

check$npr4:				; CODE XREF: check$nprs+96j
					; check$nprs+B4j
		push	bx
		inc	cx
		call	get$dm		; Get block CX from FCB; returns in BX
		pop	dx
		inc	dx
		cmp	bx, dx
		jz	check$npr4
		test	rmf, 0FFh	; Read mode flag
		jnz	check$nptr45
		or	bx, bx
		jnz	check$nptr45
		cmp	dx, dpb_dsm
		jnb	check$nptr45
		push	cx
		push	dx
		mov	cx, dx
		call	getallocbit
		pop	bx
		pop	cx
		shr	al, 1
		jnb	check$npr4

check$nptr45:				; CODE XREF: check$nprs+9Dj
					; check$nprs+A1j ...
		dec	cl
		pop	dx
		mov	al, dh
		cmp	al, cl
		jb	check$npr5
		mov	al, cl

check$npr5:				; CODE XREF: check$nprs+83j
					; check$nprs+BDj
		sub	al, dl
		mov	ch, al
		inc	ch
		mov	al, dpb_blm
		inc	al
		mul	ch
		pop	cx
		xchg	al, cl
		test	rmf, 0FFh	; Read mode flag
		jz	check$npr8
		cmp	al, cl
		jb	check$npr9

check$npr8:				; CODE XREF: check$nprs+D6j
		mov	al, cl

check$npr9:				; CODE XREF: check$nprs+74j
					; check$nprs+DAj
		pop	cx
		pop	bx
		mov	[bx], ch
		pop	cx
		mov	dh, last_sec_count
		sub	al, ch
		cmp	al, dh
		jb	check$npr10
		mov	al, dh

check$npr10:				; CODE XREF: check$nprs+EBj
		not	cl
		and	al, cl
		jz	check$npr10b
		mov	dir$cnt, al
		test	rmf, 0FFh	; Read mode flag
		jz	check$npr10a
		push	ax
		call	flushx
		pop	ax

check$npr10a:				; CODE XREF: check$nprs+FDj
		mov	cl, dpb_psh
		shr	al, cl
		mov	fs_rdwrcount, al
		or	al, 1

check$npr10b:				; CODE XREF: check$nprs+F3j
		retn	


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_readrec:				; CODE XREF: F_READ+Fj	F_READRAND+16j
		call	tst$inv$fcb
		mov	al, 0FFh
		mov	rmf, al		; Read mode flag
		call	getfcb		; Set variables	from currently addressed FCB
		mov	al, vrecord
		cmp	al, rcount
		jb	recordok	; In the current extent
		cmp	al, 80h
		jnz	setlret1	; Already off EOF
		call	open$reel	; Open the next	extent
		cmp	byte ptr aret, 0
		jnz	setlret1

recordok:				; CODE XREF: bdos:3D00j
		call	index		; Compute disk block number from current FCB
		jz	setlret1
		call	atran
		call	check$nprs
		jb	j_setfcb
		jnz	read$deblock
		jmp	go_rdbuff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

read$deblock:				; CODE XREF: bdos:3D1Dj
		call	setdata
		call	seek
		call	rdbuff

j_setfcb:				; CODE XREF: bdos:3D1Bj
		jmp	setfcb		; Place	values back into current FCB
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

setlret1:				; CODE XREF: bdos:3D04j bdos:3D0Ej
					; ...
		jmp	f_ret_1

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

setdir1:		; CODE XREF: cpm_writerec+B0p
					; fat_make+D9p	...
		mov	al, dpb_phm
		xor	ah, ah
		inc	ax
		push	ax
		mov	cl, 6
		shl	ax, cl
		xchg	ax, cx
		mov	di, dph_dirbcb
		sub	di, 0Ch

setdir1a:				; CODE XREF: setdir1+1Aj
		mov	di, 12[di]
		cmp	word ptr 12[di], 0
		jnz	setdir1a
		mov	byte ptr [di], 0FFh
		mov	di, 10[di]
		mov	word ptr fs_buffer+2, di
		mov	word ptr fs_buffer, ds
		xor	ax, ax
		rep stosw
		pop	ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

cpm_writerec:		; CODE XREF: F_WRITE+Fj F_WRITERAND+16j
					; ...
		mov	rmf, 0		; Read mode flag
		call	check$write
		mov	al, user_fcb+0Eh
		rcl	al, 1
		not	al
		test	xfcb_rdonly, al
		mov	ah, 3		; File R/O
		jz	writeseq_1

writeseq_err:				; CODE XREF: cpm_writerec+1Fj
		jmp	disk_error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

writeseq_1:				; CODE XREF: cpm_writerec+15j
		test	high$ext, 40h	; In R/O mode?
		jnz	writeseq_err
		mov	bx, offset user_fcb
		call	check$rofile
		call	tst$inv$fcb
		call	update$stamp
		call	getfcb		; Set variables	from currently addressed FCB
		mov	al, vrecord
		cmp	al, 80h
		jb	dskwrite0
		call	open$reel
		test	byte ptr aret, 0FFh
		jz	dskwrite0
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

dskwrite0:				; CODE XREF: cpm_writerec+35j
					; cpm_writerec+3Fj
		call	index		; Compute disk block number from current FCB
		jz	dskwrite2
		mov	cl, 0		; Marked as normal write operation
					; for wrbuff
		jmps	diskwr1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

dskwrite2:				; CODE XREF: cpm_writerec+45j
		call	dm$position
		mov	dminx, al
		xor	cx, cx		; May use block	zero
		or	al, al
		jz	nopblock	; Skip if no prev block
		mov	cl, al
		dec	cx
		call	get$dm		; Get block CX from FCB; returns in BX
		mov	cx, bx

nopblock:				; CODE XREF: cpm_writerec+55j
		call	get$block
		or	bx, bx		; Can't find a block?
		jnz	blockok
		mov	al, 2		; Disk full
		jmp	sta$ret
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

blockok:				; CODE XREF: cpm_writerec+64j
		mov	bcb_record, bx
		mov	dx, bx
		call	lru_touch	; Take the last	LRU buffer, move to head of chain,
					; allocate to drive bcb_drive block DX
		mov	bx, offset user_fcb+10h
		cmp	single,	0	; Nonzero if using 8-bit blocks
		mov	al, dminx
		mov	ah, 0
		jz	allocwd
		add	bx, ax
		mov	[bx], dl
		jmps	diskwru
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

allocwd:				; CODE XREF: cpm_writerec+81j
		add	bx, ax
		add	bx, ax
		mov	[bx], dx
		inc	bx

diskwru:				; CODE XREF: cpm_writerec+87j
		mov	cl, 2		; Write	to previously unallocated block

diskwr1:				; CODE XREF: cpm_writerec+49j
		mov	deblock_flag, cl
		call	atran
		cmp	fs_function, 16h; Write	random with ZF?
		jnz	dskwr11
		cmp	deblock_flag, 2
		jnz	dskwr11
		mov	deblock_flag, 0
		push	bcb_record
		call	setdir1
		push	ax
		mov	cl, dpb_blm
		call	lru_ckdirty	; Returns Carry	set if buffer dirty?
		mov	ax, bcb_dirty
		mov	cl, 2

fill1:					; CODE XREF: cpm_writerec+DDj
		mov	bcb_record, ax
		push	cx
		call	discard$databcb	; Release the BCB for bcb_drive, record	bcb_record
		call	seek
		pop	cx
		call	wrbuff
		mov	ax, bcb_record	; Restore record
		pop	bx
		push	bx
		add	ax, bx		; Continue until (blkmsk & arecord) = 0
		mov	bl, dpb_blm
		and	bl, al
		mov	cl, 0
		jnz	fill1
		pop	bx
		pop	bcb_record

dskwr11:				; CODE XREF: cpm_writerec+9Ej
					; cpm_writerec+A5j
		call	check$nprs
		jb	dont$write
		jnz	_write
		mov	ah, 2
		call	deblock$dta
		jmps	dont$write1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

_write:					; CODE XREF: cpm_writerec+E9j
		call	setdata
		call	seek
		call	discard$databcb	; Release the BCB for bcb_drive, record	bcb_record
		mov	cl, blk$off
	if PCPM204E
		call	lru_free	; Free all LRU buffers for drive bcb_drive
	else
		call	lru_ckdirty
	endif

		mov	cl, deblock_flag
		cmp	blk$off, 0
		jz	write00
		mov	cl, 0

write00:				; CODE XREF: cpm_writerec+10Bj
		call	wrbuff
		jmps	dont$write1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

dont$write:				; CODE XREF: cpm_writerec+E7j

	if	DONTWRITE_PATCH
		jmp	patch_dontwrite
	else
		call	discard$databcb
	endif

;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

dont$write1:				; CODE XREF: cpm_writerec+F0j
					; cpm_writerec+112j ...
		mov	al, vrecord
		mov	bx, offset rcount
		cmp	al, [bx]
		jb	diskwr2
		mov	[bx], al
		inc	byte ptr [bx]	; rcount = vrecord + 1
		mov	deblock_flag, 2	; Mark as record count incremented

diskwr2:				; CODE XREF: cpm_writerec+11Fj
		cmp	deblock_flag, 2
		jnz	noupdate
		and	user_fcb+0Eh, 7Fh; Reset FWF

noupdate:				; CODE XREF: cpm_writerec+12Fj
		call	getmodnum
		and	al, 40h
		jnz	diskwrite3
		or	byte ptr [bx], 40h; Set	file write flag
		and	user_fcb+0Eh, 7Fh

diskwrite3:				; CODE XREF: cpm_writerec+13Bj
		jmp	setfcb		; Place	values back into current FCB



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Convert a size (extent + record no)
; to a 3-byte record number.

extent_size:		; CODE XREF: F_SIZE+1Fp F_RANDREC+6p
					; ...
		xchg	bx, dx
		add	bx, dx
		mov	cl, [bx]
		xor	ch, ch
		mov	bx, dx
		mov	ah, 12[bx]
		shr	ax, 1
		and	ax, 0F80h
		add	cx, ax
		mov	al, 14[bx]
		and	al, 3Fh
		mov	ah, 10h
		mul	ah
		add	ch, al
		mov	al, 0
		adc	al, ah

login_fail:				; CODE XREF: compare_recno+6j
					; drive_login+Bj
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

compare_recno:		; CODE XREF: F_SIZE+22p F_TRUNCATE+34p
		mov	bx, offset user_fcb+21h
		cmp	al, 2[bx]
		jnz	login_fail
		cmp	cx, [bx]
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

drive_login:		; CODE XREF: disk$select1+Bp
		push	dx
		mov	cl, al
		mov	al, 9		; SELDSK
		call	fs_call_xios
		pop	dx
		or	bx, bx
		jz	login_fail
		inc	bx
		inc	bx
		mov	cdrmaxa, bx
		inc	bx
		inc	bx
		mov	lsn$add, bx
		add	bx, 4
		mov	si, bx
		mov	di, offset dph_dpb
		mov	cx, 0Ch
		rep movsb
		mov	si, dph_dpb
		lodsw
		cmp	ax, 0FFFEh
		jb	fs_is_cpm
		mov	max_cluster, 0FFFFh
		jz	fs_is_fat16
		mov	max_cluster, 0FFFh

fs_is_fat16:				; CODE XREF: drive_login+36j
		add	dph_dpb, 0Ch
		mov	di, offset dpb_fatcount
		mov	cx, 1Bh
		rep movsb
		test	dl, 1		; Logged in before?
		jnz	fats_loaded
		push	ax
		call	load_fats
		pop	ax
		or	bx, bx
		jz	drv_login_ret

fats_loaded:				; CODE XREF: drive_login+4Ej
		mov	ax, dpb_clustersize
		xor	dx, dx
		mov	cx, 32
		div	cx
		dec	ax
		mov	names_per_block, ax
		mov	al, 1
		jmps	have_fstype
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fs_is_cpm:				; CODE XREF: drive_login+2Ej
		mov	di, offset dpb_spt
		stosw
		mov	cx, 0Fh
		rep movsb
		xor	al, al

have_fstype:				; CODE XREF: drive_login+69j
		mov	F_isfatfs, al
		mov	al, byte ptr dpb_dsm+1
		or	al, al
		jz	fewer256blocks
		mov	al, 1

fewer256blocks:				; CODE XREF: drive_login+7Ej
		dec	al
		mov	single,	al	; Nonzero if using 8-bit blocks
		stc	

drv_login_ret:				; CODE XREF: drive_login+57j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

load_fats:		; CODE XREF: drive_login+51p
		mov	ax, dpb_firstfat
		mov	cx, dpb_fatcount

load_fat:				; CODE XREF: load_fats+3Bj
		push	ax
		push	cx
		xor	dx, dx
		div	dpb_spt
		mov	fs_track, ax
		mov	fs_sector, dx
		mov	al, byte ptr dpb_secperfat
		mov	fs_rdwrcount, al
		mov	ax, dph_hash
		mov	word ptr fs_buffer, ax
		mov	word ptr fs_buffer+2, 0
		mov	al, 0Ah		; READ
		call	xios_rdwr
		mov	bx, 1
		pop	cx
		pop	dx
		or	al, al
		jz	lfat_fail
		mov	ax, dpb_secperfat
		add	ax, dx
		loop	load_fat
		xor	bx, bx

lfat_fail:				; CODE XREF: load_fats+34j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

write_FAT:		; CODE XREF: fat_close+33p
					; fat_make+52p	...
		mov	ax, dpb_firstfat
		mov	cx, dpb_fatcount
		xor	bx, bx

write_fat_loop:				; CODE XREF: write_FAT+39j
		push	ax
		push	bx
		push	cx
		xor	dx, dx
		div	dpb_spt
		mov	fs_track, ax
		mov	fs_sector, dx
		mov	al, byte ptr dpb_secperfat
		mov	fs_rdwrcount, al
		mov	ax, dph_hash
		mov	word ptr fs_buffer, ax
		mov	word ptr fs_buffer+2, 0
		mov	al, 0Bh
		call	xios_rdwr
		pop	cx
		pop	bx
		or	bx, ax
		pop	ax
		add	ax, dpb_secperfat
		loop	write_fat_loop
		mov	al, bl
		mov	ah, 0FFh
		jmp	diocomp1



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

disk$select:		; CODE XREF: curselect+9p reselect+6Cp
		mov	bcb_drive, al



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

disk$select1:		; CODE XREF: deblock+EFp
		mov	curdsk,	al
		mov	dx, login_vector
		call	test$vector	; Return bit curdsk of vector DX
		push	dx
		call	drive_login
		pop	bx
		jnb	disk$select1a
		dec	bl
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

disk$select1a:				; CODE XREF: disk$select1+Fj
		jmp	j_fs_abort4



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

tmpselect_dir:		; CODE XREF: DRV_SETp DRV_RESET+18p
					; ...
		mov	fs_fcbdrive, dl



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

curselect_dir:		; CODE XREF: reselect+3Dp F_SFIRST+16p
					; ...
		mov	al, fs_fcbdrive
		cmp	al, 0FFh
		jnz	curselect_dir1
		inc	al
		jz	j_fs_abort4

noselect:				; CODE XREF: curselect+7j curselect+Cj
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

curselect_dir1:				; CODE XREF: curselect_dir+5j
		mov	chdir_drive, al
		mov	cur_drvdir, 0
		cmp	al, 10h
		jnb	j_fs_abort4
		mov	cl, 0
		call	cwd_for_drive



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

curselect:		; CODE XREF: tst$relog+Ap drv$relogp
					; ...
		mov	al, fs_fcbdrive

curselect0:				; CODE XREF: cwd_for_drive+1Cj
		cmp	al, curdsk
		jz	noselect
		call	disk$select
		jz	noselect
		cmp	F_isfatfs, 0
		jnz	curselect01
		call	cpm_login
		jmps	curselect02
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

curselect01:				; CODE XREF: curselect+13j
		call	fat_login

curselect02:				; CODE XREF: curselect+18j
		mov	bx, lsn$add
		mov	al, 2[bx]
		and	al, 1
		add	2[bx],	al
		mov	bx, offset login_vector
		call	set$cdisk
		cmp	dpb_cks, 8000h
		jz	curselect03
		mov	bx, offset removable_drive
		call	set$cdisk

curselect03:				; CODE XREF: curselect+35j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

cwd_for_drive:		; CODE XREF: ret_drv_vector+11p
					; curselect_dir+1Bp ...
		push	ds
		mov	ds, rlr

		mov	bx, proc_dirname
		pop	ds

		or	bx, bx
		jz	no_cwd_found
		xor	ah, ah
		mov	si, ax
		add	si, si		; +2*drive
		mov	bx, [bx+si]	; Have CWD on this drive?
		or	bx, bx
		jnz	cwd_found

no_cwd_found:				; CODE XREF: cwd_for_drive+Cj
		cmp	al, 0Dh		; Floating drive?
		jb	curselect0
		mov	al, sysvar_144
		cmp	cl, 0FFh
		jz	cwdfd_ret
		mov	fs_fcbdrive, al
		jmps	cwdfd_ret
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

j_fs_abort4:				; CODE XREF: disk$select1+14j
					; curselect_dir+9j ...
		jmp	sel$error	; Report select	error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cwd_found:				; CODE XREF: cwd_for_drive+18j
		mov	al, [bx]	; Drive	this CWD structure applies to
		cmp	cl, 0FFh
		jz	cwdfd_ret
		mov	cur_drvdir, bx
		mov	fs_fcbdrive, al
		mov	dname_cluster, 0

cwdfd_ret:				; CODE XREF: cwd_for_drive+24j
					; cwd_for_drive+29j ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

sel1_fcb_drive:		; CODE XREF: F_SFIRST+20p F_MAKE+Bp
					; ...
		xor	al, al
		mov	high$ext, al
		mov	xfcb_rdonly, al
		jmps	sel_fcb_drive



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

reselect:		; CODE XREF: F_do_call+24p
		mov	cx, 807Fh
		mov	bx, offset user_fcb+7
		mov	al, [bx]
		and	al, ch
		mov	xfcb_rdonly, al
		and	[bx], cl
		inc	bx
		mov	al, [bx]
		and	al, cl
		cmp	al, [bx]
		mov	[bx], al
		mov	al, 60h		; If F8' was set, assume top 3 bits
					; of EX	are 011
		jnz	got_exflags
		mov	al, 4[bx]
		and	al, 0E0h	; Top 3	bits of	EX

got_exflags:				; CODE XREF: reselect+1Aj
		mov	high$ext, al
		call	clr$ext

sel_fcb_drive:				; CODE XREF: sel1_fcb_drive+8j
		mov	set_if_attrs, 0FFh
		mov	al, user_fcb
		mov	fcbdsk,	al
		and	al, 1Fh
		dec	al
		cmp	al, 0FFh
		jz	_noselect
		mov	fs_fcbdrive, al

_noselect:				; CODE XREF: reselect+38j
		call	curselect_dir
		mov	al, usrcode
		mov	user_fcb, al

noselect0:				; CODE XREF: F_SFIRST+19p
		call	tst$log$fxs
		jnz	dont_discard
		mov	dir_check_flag,	0F0h

dont_discard:				; CODE XREF: reselect+49j
		call	check$media
		xor	al, al
		xchg	al, xios_bh_gdopen
		test	al, al
		jnz	check_all_media
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

check_all_media:			; CODE XREF: reselect+5Bj
		mov	bx, login_vector
		mov	al, 10h

chk$am1:				; CODE XREF: reselect+92j
		dec	al
		shl	bx, 1
		jnb	chk$am2
		push	ax
		push	bx
		call	disk$select
		mov	bx, dph_dtabcb
		mov	bx, [bx]

reselect2:				; CODE XREF: reselect+89j
		or	bx, bx
		jz	reselect5
		mov	al, bcb_drive
		cmp	al, [bx]
		jnz	reselect3
		test	byte ptr 4[bx], 0FFh
		jnz	reselect4

reselect3:				; CODE XREF: reselect+7Ej
		mov	bx, 12[bx]
		jmps	reselect2
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

reselect4:				; CODE XREF: reselect+84j
		call	check$media

reselect5:				; CODE XREF: reselect+77j
		pop	bx
		pop	ax

chk$am2:				; CODE XREF: reselect+68j
		or	al, al
		jnz	chk$am1
		jmp	curselect



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

check$media:		; CODE XREF: reselect+50p reselect+8Bp
					; ...
		mov	bx, lsn$add
		xor	al, al
		xchg	al, 1[bx]
		or	al, al
		jz	no_media_flag
		call	discard$dir	; Release all directory	BCBs for a drive
		push	dcnt
		call	set$end$dir

check$media1:				; CODE XREF: check$media+43j
		mov	cl, 0
		call	r$dir
		xor	al, al
		xchg	al, relog
		test	al, al
		jz	check$media2
		cmp	fs_function, 1Ah
		jz	check$media$end
		mov	al, bcb_drive
		cmp	al, fs_fcbdrive
		jnz	check$media$end
		pop	dcnt
		call	drv$relog
		jmp	chk$exit$fxs
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

check$media2:				; CODE XREF: check$media+24j
		call	compcdr
		jb	check$media1

check$media$end:			; CODE XREF: check$media+2Bj
					; check$media+34j
		pop	dcnt

no_media_flag:				; CODE XREF: check$media+Bj
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

copy8fromdma:		; CODE XREF: F_OPENp F_DELETEp
					; ...
		mov	cl, 8



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

copyfromdma:		; CODE XREF: F_MAKE+2p	DRV_SETLABEL+2p
					; ...
		mov	si, userdma
		mov	di, offset passwd_buf
		push	ds
		mov	ds, userdmaseg
		xor	ch, ch
		rep movsb
		pop	ds
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get$dir$mode:		; CODE XREF: cpm_delete+20p
					; cpm_delete+31p ...
		mov	bx, lsn$add
		mov	al, [bx]
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get$xfcb:		; CODE XREF: chk$pw$error+46p
					; chk$pw$error+75p ...
		mov	bx, offset user_fcb
		mov	al, [bx]
		push	ax
		or	byte ptr [bx], 10h
		call	search$extnum	; Find any extent of a file
		pop	ax
		mov	user_fcb, al
		mov	byte ptr aret, 0
		jnz	get$xfcb1
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get$xfcb1:		; CODE XREF: get$xfcb+15j chk_xfcb_passwdp
					; ...
		call	getdptra
		mov	dx, bx
		add	bx, 0Ch
		mov	al, [bx]
		and	al, 0E0h
		or	al, 1
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

init$xfcb:		; CODE XREF: F_MAKE+B1p DRV_SETLABEL+46p
					; ...
		call	setcdr
		mov	cx, 1014h



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

init$xfcb0:		; CODE XREF: DRV_SETLABEL+65p
		push	cx
		call	getdptra
		mov	si, offset user_fcb
		lodsb
		or	al, ch
		mov	[bx], al
		inc	bx
		mov	cl, 0Bh
		mov	dx, si
		call	move		; Copy CL bytes	from DX	to BX
		mov	dx, si
		mov	bx, di
		pop	cx
		sub	ch, ch
		xor	al, al
		rep stosb
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

chk$pw$error:		; CODE XREF: cpm_delete+3Dp
					; openx+71p ...
		mov	byte ptr xdcnt+1, 0; Disable special searches
		mov	si, offset user_fcb
		mov	di, offset passwd_fcb
		mov	cx, 10h
		rep movsb
		call	getdptra	; Find XFCB with ext=0 S2=0
		mov	si, bx
		inc	si
		mov	di, offset user_fcb+1
		mov	cx, 0Bh		; Copy name.type
		rep movsb
		xor	al, al
		stosb			; Blank	EX
		inc	di
		stosb			; Blank	S2
		lodsb			; Password mode
		mov	pw$mode, al	; Password mode
		call	search$namlen	; Find a numbered extent
		jz	chk$pwe2
		call	get$dtba$8	; Does SFCB exist for FCB?
		or	al, al
		jnz	chk$pwe1
		mov	si, offset pw$mode; Password mode
		mov	ch, [si]
		mov	al, [bx]
		mov	[si], al
		or	al, al		; Is SFCB password mode	nonzero?
		jz	chk$pwe2	; No
		xor	al, ch		; Does XFCB mode match SFCB?
		and	al, 0E0h
		jz	chk$pwe1
		call	get$xfcb	; Update XFCB to match SFCB
		jz	chk$pwe1
		mov	al, pw$mode	; Password mode
		mov	[bx], al
		call	nowrite		; Return true if drive is software R/O
		jnz	chk$pwe1
		call	seek$copy

chk$pwe1:				; CODE XREF: chk$pw$error+31j
					; chk$pw$error+44j ...
		call	restore$pw$fcb
		mov	al, fs_function
		cmp	al, 2		; F_OPEN
		jz	chk_pwe_ret
		cmp	al, 9		; F_MAKE
		jz	chk_pwe_ret

pw$error:				; CODE XREF: openx+7Fj	F_MAKE+6Ej
					; ...
		mov	ah, 7
		jmp	disk_error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

chk$pwe2:				; CODE XREF: chk$pw$error+2Aj
					; chk$pw$error+3Ej
		mov	pw$mode, 0	; Password mode
		call	nowrite		; Return true if drive is software R/O
		jnz	restore$pw$fcb
		call	get$xfcb	; Delete XFCB
		jz	restore$pw$fcb
		or	user_fcb, 10h
		call	delete11



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

restore$pw$fcb:		; CODE XREF: chk$pw$error+58p
					; chk$pw$error+73j ...
		mov	si, offset passwd_fcb
		mov	di, offset user_fcb
		mov	cx, 10h
		rep movsb

chk_pwe_ret:				; CODE XREF: chk$pw$error+60j
					; chk$pw$error+64j ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

chk$password:		; CODE XREF: bdos:479Dp F_ATTRIB+13p
					; ...
		call	get$dir$mode
		and	al, 80h
		jz	chk_pwe_ret
		call	get$xfcb
		jz	chk_pwe_ret



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Compare password

cmp$pw:		; CODE XREF: chk_xfcb_passwd+4p
					; openx+6Cp
		inc	bx
		mov	ch, [bx]
		or	ch, ch
		jnz	cmp$pw2
		mov	si, bx
		add	si, 3
		mov	cl, 9

cmp$pw1:				; CODE XREF: cmp$pw+15j cmp$pw+19j
		lodsb
		dec	cl
		jz	chk_pwe_ret
		or	al, al
		jz	cmp$pw1
		cmp	al, 20h
		jz	cmp$pw1

cmp$pw2:				; CODE XREF: cmp$pw+5j
		lea	si, 10[bx]
		lea	dx, 3[bx]
		mov	bx, offset passwd_buf
		mov	cl, 8
		std	

cmp$pw3:				; CODE XREF: cmp$pw+31j
		lodsb
		xor	al, ch
		cmp	al, [bx]
		jnz	cmp$pw5
		inc	bx
		dec	cl
		jnz	cmp$pw3
		cld	
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cmp$pw5:				; CODE XREF: cmp$pw+2Cj
		cld	
		mov	bx, offset df$password;	Default	password
		mov	cl, 8
		jmp	compare		; Compare CL bytes at DX and BX



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

chk_xfcb_passwd:		; CODE XREF: cpm_delete+38p
					; DRV_SETLABEL+5Bp ...
		call	get$xfcb1

chk_xfcb_passw1:			; CODE XREF: F_MAKE+5Fp
		push	bx
		call	cmp$pw		; Compare password
		pop	bx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set$pw:		; CODE XREF: F_MAKE+CEp sdl2+9p
		mov	cx, 8
		lea	di, 11[bx]

set$pw0:				; CODE XREF: F_PASSWD+15j
		sub	ah, ah

set$pw1:				; CODE XREF: set$pw+1Aj
		lodsb
		mov	[di], al
		or	al, al
		jz	set$pw2
		cmp	al, 20h
		jz	set$pw2
		inc	ah

set$pw2:				; CODE XREF: set$pw+Dj	set$pw+11j
		add	ch, al
		dec	di
		dec	cl
		jnz	set$pw1
		or	ah, ch
		jnz	set$pw3
		mov	[bx], ah

set$pw3:				; CODE XREF: set$pw+1Ej
		inc	di
		mov	cl, 8

set$pw4:				; CODE XREF: set$pw+2Aj
		xor	[di], ch
		inc	di
		dec	cl
		jnz	set$pw4
		mov	1[bx],	ch
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get$dtba$8:		; CODE XREF: delete11+14p chk$pw$error+2Cp
					; ...
		mov	ch, 8

get$dtba:				; CODE XREF: make+47p stamp2+2p
					; ...
		mov	al, 3
		mov	ah, byte ptr dcnt
		and	ah, 3
		cmp	al, ah
		jz	get$dtba$ret
		mov	bx, buffa
		add	bx, 60h
		mov	al, [bx]
		sub	al, 21h
		jnz	get$dtba$ret
		mov	al, ah
		mov	cl, 0Ah
		mul	cl
		inc	al
		add	al, ch
		add	bx, ax
		xor	al, al

get$dtba$ret:				; CODE XREF: get$dtba$8+Dj
					; get$dtba$8+1Aj ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

qdirfcb1:		; CODE XREF: qstampp openx+31p
					; ...
		mov	bx, offset user_fcb+0Ch
		mov	al, [bx]
		mov	ah, dpb_exm
		not	ah
		and	al, ah
		and	al, 1Fh
		jnz	get$dtba$ret
		test	byte ptr 2[bx], 3Fh
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

qstamp:		; CODE XREF: openx2p F_MAKE+EFp
					; ...
		call	qdirfcb1
		jnz	get$dtba$ret



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

qstamp1:		; CODE XREF: update$stamp+2p
		call	get$dir$mode
		and	al, cl
		jz	qstamp1a
		jmp	nowrite		; Return true if drive is software R/O
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

qstamp1a:				; CODE XREF: qstamp1+5j
		inc	al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

stamp1:		; CODE XREF: openx2+5j	DRV_SETLABEL+4Fp
		mov	ch, 0
		jmps	stamp3



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

stamp2:		; CODE XREF: update$stamp+1Bp
					; F_MAKE+F4p ...
		mov	ch, 4

stamp3:					; CODE XREF: stamp1+2j
		call	get$dtba
		or	al, al
		jnz	get$dtba$ret

stamp_cmpdate:				; CODE XREF: stamp5+9j
		mov	dx, offset date_days

stamp_compare:				; CODE XREF: F_BDOS_74+3Bp
					; F_BDOS_74+51p
		mov	cl, 4
		push	bx
		push	dx
		call	compare		; Compare CL bytes at DX and BX
		pop	dx
		pop	bx
		jz	get$dtba$ret
		mov	cl, 4
		call	move		; Copy CL bytes	from DX	to BX
		jmp	seek$copy



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

stamp5:		; CODE XREF: DRV_SETLABEL+4Cp
					; DRV_SETLABEL+55p
		call	getdptra
		add	bx, cx
		mov	ax, offset F_nop
		push	ax
		jmps	stamp_cmpdate



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

update$stamp:		; CODE XREF: cpm_writerec+2Ap
					; F_TRUNCATE+8Ap
		mov	cl, 20h		; Is update stamping requested?
		call	qstamp1
		jnz	get$dtba$ret
		test	user_fcb+0Eh, 40h; Has file been written to?
		jnz	get$dtba$ret
		mov	ah, user_fcb+0Ch; Save EX and S2
		mov	al, user_fcb+0Eh
		push	ax
		call	find_extent_0	; Find the SFCB
		jz	no_stamp2
		call	stamp2

no_stamp2:				; CODE XREF: update$stamp+19j
		mov	byte ptr aret, 0
		pop	ax
		mov	user_fcb+0Ch, ah
		mov	user_fcb+0Eh, al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

dirdata_alloc:		; CODE XREF: cpm_opendir+E5p
		cli	
		mov	bx, free_dirdata
		or	bx, bx
		jz	dda_allgone
		mov	si, [bx]
		mov	free_dirdata, si

dda_allgone:				; CODE XREF: dirdata_alloc+7j
		sti	
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

intrnldiskreset:		; CODE XREF: DRV_SETRO+9p
		mov	dx, bx
		mov	cx, 3

dskrst0:				; CODE XREF: intrnldiskreset+1Fj
		shl	bx, 1
		jnb	dskrst1
		push	cx
		push	bx
		mov	al, cl
		add	al, 0Ch
		mov	cl, 0FFh
		call	cwd_for_drive
		mov	cl, al
		mov	ax, 1
		shl	ax, cl
		or	dx, ax
		pop	bx
		pop	cx

dskrst1:				; CODE XREF: intrnldiskreset+7j
		loop	dskrst0
		and	dx, 1FFFh
		mov	bx, dx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Return bitmap	of all drives in use by	processes

get_drvs_in_use:		; CODE XREF: not_drv_loggedp
					; DRV_RESETp
		xor	ax, ax
		push	es
		mov	es, bdos_conowner


gdiu_0:					; CODE XREF: get_drvs_in_use+1Dj
		cmp	es:proc_status,	2; 0 =>	Runnable
					; 1 => waiting on timer
					; 2 => terminated
					; 3 => waiting on flag
		jz	gdiu_1
		or	ax, es:proc_using_drvs

gdiu_1:					; CODE XREF: get_drvs_in_use+Dj
		mov	cx, es:proc_nextseg
		mov	es, cx
		or	cx, cx
		jnz	gdiu_0
		pop	es
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

not_drv_logged:		; CODE XREF: DRV_FLUSH+2Cp
					; DRV_FLUSH+63p
		call	get_drvs_in_use	; Return bitmap	of all drives in use by	processes
		not	ax
		mov	dx, ax
		jmp	test$vector	; Return bit curdsk of vector DX


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ
		call	end$of$dir
		mov	cl, 0
		jmp	read$dir

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

DRV_ALLRESET:		; DATA XREF: bdos:256Eo
		mov	ax, 0FFFFh
		mov	fs_param_low, ax
		call	DRV_RESET
		xor	al, al		; A: is	the default
		call	set_proc_drive
		dec	al		; But no drive is logged in
		mov	curdsk,	al
		push	ds
		mov	ds, rlr

		mov	word ptr proc_dma, 80h
		pop	ds

		jmp	DRV_FLUSH



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

DRV_SET:		; DATA XREF: bdos:2571o
		call	tmpselect_dir
		mov	al, linfo



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set_proc_drive:		; CODE XREF: DRV_ALLRESET+Bp
		push	ds
		mov	ds, rlr

		mov	proc_drive, al
		pop	ds


spd_ret:				; CODE XREF: F_OPEN+20j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_OPEN:		; DATA XREF: bdos:2574o
		call	copy8fromdma	; Get password
		call	clrmodnum	; Clear	S2 byte	of FCB
		cmp	F_isfatfs, 0
		jz	cpm_open
		jmp	fat_open
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_open:				; CODE XREF: F_OPEN+Bj
		test	fcb_is_for_dir,	0FFh
		jz	cpm_openfile
		call	cpm_opendir
		cmp	aret, 0FFh
		jnz	spd_ret
		mov	aret, 0FFh
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_openfile:				; CODE XREF: F_OPEN+15j
		call	check$wild
		cmp	usrcode, 0
		jz	call$open
		mov	al, 0FEh
		mov	byte ptr xdcnt+1, al
		inc	al
		mov	search$user0, al

call$open:				; CODE XREF: F_OPEN+31j
		call	open
		call	openx
		xor	al, al
		xchg	al, search$user0
		test	al, al
		jnz	callopen_noret

callopen_ret:				; CODE XREF: F_OPEN+53j openx+3j
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

callopen_noret:				; CODE XREF: F_OPEN+4Bj
		cmp	byte ptr xdcnt+1, 0FEh
		jz	callopen_ret
		call	set_dcnt_dblk
		mov	high$ext, 60h
		xor	al, al		; Try to open in user 0
		mov	user_fcb, al
		mov	cl, 0Fh
		call	searchi
		call	searchn		; Search for the next directory	element,
					; assuming a previous call on search
		call	open1
		call	openx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

openx:		; CODE XREF: F_OPEN+40p F_OPEN+6Dp
		call	end$of$dir
		jz	callopen_ret
		mov	bx, offset user_fcb+20h
		cmp	byte ptr [bx], 0FFh
		jnz	openxa
		mov	al, user_fcb+0Dh
		mov	[bx], al

openxa:					; CODE XREF: openx+Bj
		pop	bx		; Open successful. Discard return address
		mov	al, high$ext
		cmp	al, 60h
		jnz	openx0
		mov	al, user_fcb+0Ah; System file?
		and	al, 80h
		jnz	openx0		; Yes -	open successful
		mov	high$ext, al
		jmp	lret$eq$ff	; Open fails
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

openx0:					; CODE XREF: openx+18j	openx+1Fj
		call	set$lsn
		call	get$dir$mode	; Are passwords	enabled	on drive?
		test	al, 80h
		jz	openx1a
		call	qdirfcb1	; Is this the first dir	fcb?
		jnz	openx0a
		call	get$dtba$8	; Does SFCB exist?
		or	al, al
		jnz	openx0a
		test	byte ptr [bx], 0C0h; Password read/write?
		jz	openx1a
		call	xdcnt_eq_dcnt	; Does XFCB exist?
		call	get$xfcb
		jnz	openx0b
		call	restore_dir_fcb
		jz	openxret
		call	get$dtba
		or	al, al
		jnz	openx1a
		mov	[bx], al
		call	nowrite		; Return true if drive is software R/O
		jnz	openx1a
		call	seek$copy
		jmps	openx1a
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

openx0a:				; CODE XREF: openx+34j	openx+3Bj
		call	xdcnt_eq_dcnt
		call	get$xfcb
		and	al, 0C0h
		jz	openx1

openx0b:				; CODE XREF: openx+48j
		call	cmp$pw		; Compare password
		jz	openx1
		call	chk$pw$error
		mov	al, pw$mode	; Password mode
		and	al, 0C0h
		jz	openx1
		test	al, 80h
		jz	openx0c
		jmp	pw$error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

openx0c:				; CODE XREF: openx+7Dj
		mov	xfcb_rdonly, 80h; Can only open	read-only

openx1:					; CODE XREF: openx+6Aj	openx+6Fj
					; ...
		call	restore_dir_fcb
		jnz	openx1a

openxret:				; CODE XREF: openx+4Dj
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

openx1a:				; CODE XREF: openx+2Fj	openx+40j
					; ...
		call	set$lsn
		mov	open_unknown, 0FFh
		mov	cl, 40h



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

openx2:		; CODE XREF: F_MAKE+EAp
		call	qstamp
		jnz	openx2_ret
		jmp	stamp1



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_CLOSE:		; DATA XREF: bdos:2577o
		cmp	F_isfatfs, 0
		jz	close_file
		test	fcb_is_for_dir,	0FFh
		jz	close_file
		jmp	fat_close
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

close_file:				; CODE XREF: F_CLOSE+5j F_CLOSE+Cj
		cmp	F_isfatfs, 0
		jz	cpm_close
		jmp	fat_close
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_close:				; CODE XREF: F_CLOSE+16j
		test	fcb_is_for_dir,	0FFh
		jz	cpm_closefile
		mov	aret, 0
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_closefile:				; CODE XREF: F_CLOSE+20j
		call	set$lsn
		call	chek$fcb
		call	close
		cmp	byte ptr aret, 0FFh
		jnz	f_close_flush

openx2_ret:				; CODE XREF: openx2+3j
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

f_close_flush:				; CODE XREF: F_CLOSE+37j
		call	call_xios_flush

f_close_end:				; CODE XREF: fat_close+50j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_SFIRST:		; DATA XREF: bdos:257Ao
		mov	ax, fs_param_ds
		mov	word ptr sys_find1st+2,	ax
		mov	ax, fs_param_low
		mov	word ptr sys_find1st, ax
		xor	al, al

csearch:				; CODE XREF: bdos:464Aj
		pushf	
		cmp	user_fcb, '?'   ; If drive byte is '?', search
					; the default drive.
		jnz	csearch1
		call	curselect_dir
		call	noselect0
		xor	cl, cl
		jmps	csearch3
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

csearch1:				; CODE XREF: F_SFIRST+14j
		call	sel1_fcb_drive
		mov	cl, 0Ch
		mov	bx, offset user_fcb+0Ch
		cmp	byte ptr [bx], 3Fh
		jz	csearch3
		call	clr$ext
		call	clrmodnum	; Clear	S2 byte	of FCB
		mov	cl, 0Fh

csearch3:				; CODE XREF: F_SFIRST+1Ej F_SFIRST+2Bj
		or	dir_check_flag,	0Fh
		cmp	F_isfatfs, 0
		jz	srch_cpm
		jmp	srch_fat
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

srch_cpm:				; CODE XREF: F_SFIRST+3Fj
		push	cs
		call	f_interrupt
		jnz	srch_1
		call	search
		jmps	srch_found
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

srch_1:					; CODE XREF: F_SFIRST+48j
		mov	cl, searchl
		call	searchi
		call	searchn		; Search for the next directory	element,
					; assuming a previous call on search

srch_found:				; CODE XREF: F_SFIRST+4Dj
		cmp	byte ptr aret, 0FFh
		jz	srch_ret
		mov	ax, dcnt
		and	al, 3
		mov	byte ptr aret, al
		mov	dx, buffa
		mov	bx, userdma
		mov	cl, 80h
		push	es
		mov	es, userdmaseg
		call	move		; Copy CL bytes	from DX	to BX
		pop	es

srch_ret:				; CODE XREF: F_SFIRST+5Ej bdos:4620j
		retn	


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

F_SNEXT:				; DATA XREF: bdos:257Do
		mov	ax, word ptr sys_find1st+2
		or	ax, word ptr sys_find1st
		jz	srch_ret
		mov	ax, word ptr sys_find1st+2
		mov	fs_param_ds, ax
		mov	ax, word ptr sys_find1st
		mov	fs_param_low, ax
		call	copy_fcb_33
		mov	searcha, offset	user_fcb
		test	user_fcb, 80h
		jz	f_snext_file
		and	user_fcb, 3Fh
		mov	fcb_is_for_dir,	0FFh

f_snext_file:				; CODE XREF: bdos:463Cj
		or	al, 1
		jmp	csearch

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_DELETE:		; DATA XREF: bdos:2580o
		call	copy8fromdma
		cmp	F_isfatfs, 0
		jz	nonfat_delete
		jmp	fat_delete
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

nonfat_delete:				; CODE XREF: F_DELETE+8j
		test	fcb_is_for_dir,	0FFh
		jz	j_cpm_delete
		mov	aret, 0FFh
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

j_cpm_delete:				; CODE XREF: F_DELETE+12j
		jmp	cpm_delete



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_READ:		; DATA XREF: bdos:2583o
		call	check_changed
		cmp	F_isfatfs, 0
		jz	j_cpm_readrec
		mov	cl, 1
		jmp	fat_rdwr	; CL: Bit 0=1 for read,	0 for write
					;     Bit 1=1 for rand,	0 for seq
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

j_cpm_readrec:				; CODE XREF: F_READ+8j
		jmp	cpm_readrec



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_WRITE:		; DATA XREF: bdos:2586o
		call	check_changed
		cmp	F_isfatfs, 0
		jz	j_cpm_writerec
		mov	cl, 0
		jmp	fat_rdwr	; CL: Bit 0=1 for read,	0 for write
					;     Bit 1=1 for rand,	0 for seq
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

j_cpm_writerec:				; CODE XREF: F_WRITE+8j
		jmp	cpm_writerec



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_MAKE:		; DATA XREF: bdos:2589o
		mov	cl, 9
		call	copyfromdma	; New password & mode
		call	clr$ext
		call	clrmodnum	; Clear	S2 byte	of FCB
		call	sel1_fcb_drive
		mov	dl, 1
		call	valid_dl_f_fcb
		mov	xdcnt, 0FFFFh
		cmp	F_isfatfs, 0
		jz	cpm_make
		jmp	fat_make
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_make:				; CODE XREF: F_MAKE+1Ej
		test	fcb_is_for_dir,	0FFh
		jz	cpm_makefile
		mov	aret, 0FFh
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_makefile:				; CODE XREF: F_MAKE+28j
		call	get$atts
		call	open
		call	end$of$dir
		jz	makea0
		call	get$dir$ext	; Compute directory extent from	FCB
		cmp	al, [bx]
		jb	makea0
		mov	ah, 8
		jmp	disk_error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

makea0:					; CODE XREF: F_MAKE+3Aj F_MAKE+41j
		pushf	
		call	f_make_nop
		call	qdirfcb1
		jz	makex04
		call	get$dir$mode
		and	al, 80h
		jz	makex04
		call	get$xfcb
		and	al, 0C0h
		jz	makex04
		call	chk_xfcb_passw1
		jz	makex04
		call	chk$pw$error
		test	pw$mode, 0C0h	; Password mode
		jz	makex04
		jmp	pw$error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

makex04:				; CODE XREF: F_MAKE+4Fj F_MAKE+56j
					; ...
		push	cs
		call	f_interrupt
		jb	makex05
		call	make

makex05:				; CODE XREF: F_MAKE+75j
		call	end$of$dir
		jnz	makex06

f_make_ret:				; CODE XREF: F_MAKE+D7j
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

makex06:				; CODE XREF: F_MAKE+7Dj
		call	set$lsn
		call	get$dir$mode
		test	al, 80h
		jz	make3a
		test	attributes, 40h	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		jz	make3a
		call	qdirfcb1
		jnz	make3a
		call	xdcnt_eq_dcnt
		call	get$xfcb
		jnz	make00
		mov	make$xfcb, 0FFh
		call	make
		jnz	make00
		call	search$namlen	; Find a numbered extent
		call	delete10
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

make00:					; CODE XREF: F_MAKE+9Cj F_MAKE+A6j
		call	init$xfcb
		mov	si, offset passwd_buf
		add	si, 8
		lodsb
		and	al, 0E0h
		jnz	make2
		mov	al, 80h

make2:					; CODE XREF: F_MAKE+BDj
		mov	pw$mode, al	; Password mode
		push	ax
		call	get$xfcb1
		pop	ax
		mov	[bx], al
		mov	si, offset passwd_buf
		call	set$pw
		call	sdl3
		call	restore_dir_fcb
		jz	f_make_ret
		call	get$dtba$8
		or	al, al
		jnz	make3a
		mov	al, pw$mode	; Password mode
		mov	[bx], al
		call	seek$copy

make3a:					; CODE XREF: F_MAKE+88j F_MAKE+8Fj
					; ...
		mov	cl, 50h
		call	openx2
		mov	cl, 20h
		call	qstamp
		jnz	f_make_ret2
		call	stamp2
		or	user_fcb+0Eh, 40h

f_make_ret2:				; CODE XREF: F_MAKE+F2j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

f_make_nop:		; CODE XREF: F_MAKE+49p
		retn	


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

F_RENAME:				; DATA XREF: bdos:258Co
		call	copy8fromdma
		call	check$wild
		cmp	F_isfatfs, 0
		jz	cpm_rename
		jmp	fat_rename
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_rename:				; CODE XREF: bdos:4798j
		call	chk$password
		jz	cpm_rename1
		call	chk$pw$error

cpm_rename1:				; CODE XREF: bdos:47A0j
		call	init_xfcb_srch
		call	copy$user$no
		mov	searcha, bx
		mov	dl, 1
		call	check$wild0
		mov	ah, 9
		jz	ren_wildcarderr
		mov	cl, 0Ch
		call	searchi1
		call	search1
		jz	cpm_rename2
		mov	ah, 8		; File exists

ren_wildcarderr:			; CODE XREF: bdos:47B6j
		mov	cur_fcb_len, 0
		add	fs_param_low, 10h
		jmp	disk_error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_rename2:				; CODE XREF: bdos:47C0j
		call	does$xfcb$exist
		jz	cpm_rename3	; If XFCB exists for new name, delete it
		call	delete11

cpm_rename3:				; CODE XREF: bdos:47D4j
		call	copy$user$no
		call	init_xfcb_srch
		call	search$extnum	; Find any extent of a file
		jnz	cpm_rename4
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_rename4:				; CODE XREF: bdos:47E2j
		call	check$rodir

rename0:				; CODE XREF: bdos:47F5j bdos:4802j
		mov	cl, 10h		; Not end of dir, rename next element
		mov	dl, 0Ch
		call	copy$dir	; Copy FCB information starting	at CL for DL bytes
					; into the currently addressed directory entry
		call	fix$hash
		call	searchn		; Search for the next directory	element,
					; assuming a previous call on search
		jnz	rename0
		call	does$xfcb$exist
		jnz	cpm_rename_5
		jmp	copy$dir$loc
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_rename_5:				; CODE XREF: bdos:47FAj
		call	copy$user$no
		jmps	rename0

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

DRV_ALLOCVEC:		; DATA XREF: bdos:258Fo
		call	curselect_dir
		mov	f_ret_es, ds
		mov	bx, dph_alv
		jmps	f_ret_bx



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

DRV_SETRO:		; DATA XREF: bdos:2592o
		mov	cl, fs_fcbdrive
		mov	bx, 1
		shl	bx, cl
		call	intrnldiskreset
		or	readonly_vector, bx
		mov	dx, dpb_drm
		inc	dx
		mov	bx, cdrmaxa
		mov	[bx], dx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_ATTRIB:		; DATA XREF: bdos:2595o
		call	copy8fromdma
		call	check$wild
		call	sel1_fcb_drive
		cmp	F_isfatfs, 0
		jz	f_attrib_cpm
		jmp	f_attrib_fat
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

f_attrib_cpm:				; CODE XREF: F_ATTRIB+Ej
		call	chk$password
		jz	f_attrib_cpm1
		call	chk$pw$error

f_attrib_cpm1:				; CODE XREF: F_ATTRIB+16j
		call	get$atts
		call	search$extnum	; Find any extent of a file
		jz	rdrand_ret

f_attrib_cpm2:				; CODE XREF: F_ATTRIB+40j
		mov	cl, 0
		mov	dl, 0Ch
		call	copy$dir2
		call	move		; Copy CL bytes	from DX	to BX
		test	attributes, 40h	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		jz	no_bytesize
		mov	al, user_fcb+20h
		mov	13[bx], al

no_bytesize:				; CODE XREF: F_ATTRIB+32j
		call	seek$copy
		call	searchn		; Search for the next directory	element,
					; assuming a previous call on search
		jnz	f_attrib_cpm2
		jmp	copy$dir$loc
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

DRV_DPB:				; DATA XREF: bdos:2598o
		call	curselect_dir
		mov	dir_check_flag,	0F0h
		call	check$media
		mov	f_ret_es, ds
		mov	bx, dph_dpb

f_ret_bx:				; CODE XREF: DRV_ALLOCVEC+Bj
		mov	aret, bx

rdrand_ret:				; CODE XREF: F_ATTRIB+21j F_READRAND+14j
					; ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_READRAND:		; DATA XREF: bdos:259Bo
		call	check_changed
		cmp	F_isfatfs, 0
		jz	cpm_readrand
		mov	cl, 3
		jmp	fat_rdwr	; CL: Bit 0=1 for read,	0 for write
					;     Bit 1=1 for rand,	0 for seq
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_readrand:				; CODE XREF: F_READRAND+8j
		mov	cl, 0FFh
		call	cpm_rwrand	; CL=-1	read  0	write
		jnz	rdrand_ret
		jmp	cpm_readrec



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_WRITERAND:		; DATA XREF: bdos:259Eo
		call	check_changed
		cmp	F_isfatfs, 0
		jz	f_writerand_cpm
		mov	cl, 2
		jmp	fat_rdwr	; CL: Bit 0=1 for read,	0 for write
					;     Bit 1=1 for rand,	0 for seq
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

f_writerand_cpm:			; CODE XREF: F_WRITERAND+8j
		mov	cl, 0
		call	cpm_rwrand	; CL=-1	read  0	write
		jnz	rdrand_ret
		jmp	cpm_writerec



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_SIZE:		; DATA XREF: bdos:25A1o
		cmp	F_isfatfs, 0
		jz	cpm_size
		jmp	fat_size
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_size:				; CODE XREF: F_SIZE+5j
		mov	bx, offset user_fcb+21h
		xor	ax, ax
		mov	[bx], ax
		mov	2[bx],	al
		call	search$extnum	; Find any extent of a file
		jz	cpm_size_notfnd

cpm_size_loop:				; CODE XREF: F_SIZE+34j
		call	getdptra
		mov	dx, 0Fh
		call	extent_size	; Take the largest value of the	
					; file sizes given by the various 
					; extents
		call	compare_recno
		jb	cpm_size_next
		mov	2[bx],	al
		mov	[bx], cx

cpm_size_next:				; CODE XREF: F_SIZE+25j
		call	searchn		; Search for the next directory	element,
					; assuming a previous call on search
		mov	byte ptr aret, 0
		jnz	cpm_size_loop

cpm_size_notfnd:			; CODE XREF: F_SIZE+17j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_RANDREC:		; DATA XREF: bdos:25A4o
		mov	bx, offset user_fcb
		mov	dx, 20h
		call	extent_size	; Convert a size (extent + record no)
					; to a 3-byte record number.
		mov	21h[bx], cx
		mov	23h[bx], al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

DRV_RESET:		; CODE XREF: DRV_ALLRESET+6p
					; DATA XREF: bdos:25A7o
		call	get_drvs_in_use	; Return bitmap	of all drives in use by	processes
		push	ax
		and	ax, fs_param_low
		jz	reset_none
		and	ax, removable_drive
		mov	dl, 10h

reset_loops:				; CODE XREF: DRV_RESET+2Cj
		dec	dl
		shl	ax, 1
		jnb	reset_next
		push	ax
		push	dx
		call	tmpselect_dir
		mov	bx, lsn$add
		mov	byte ptr 1[bx], 0FFh
		mov	xios_bh_gdopen,	0FFh
		pop	dx
		pop	ax

reset_next:				; CODE XREF: DRV_RESET+14j
		or	ax, ax
		jnz	reset_loops

reset_none:				; CODE XREF: DRV_RESET+8j
		pop	ax
		not	ax
		and	ax, fs_param_low

reset37x:				; CODE XREF: media$change+15j
		not	ax
		and	login_vector, ax
		and	readonly_vector, ax
		and	removable_drive, ax
		mov	curdsk,	0FFh
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_WRITEZF:		; DATA XREF: bdos:25B0o
		call	check_changed
		cmp	F_isfatfs, 0
		jz	cpm_writezf
		mov	cl, 2
		jmp	fat_rdwr	; CL: Bit 0=1 for read,	0 for write
					;     Bit 1=1 for rand,	0 for seq
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_writezf:				; CODE XREF: F_WRITEZF+8j
		mov	cl, 0
		call	cpm_rwrand	; CL=-1	read  0	write
		jz	j_fat_wrrec2
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

j_fat_wrrec2:				; CODE XREF: F_WRITEZF+14j
		jmp	cpm_writerec



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

DRV_SPACE:		; DATA XREF: bdos:25B9o
		call	tmpselect_dir
		cmp	F_isfatfs, 0
		jz	cpm_space
		jmp	fat_space
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_space:				; CODE XREF: DRV_SPACE+8j
		mov	si, dph_alv
		call	get$nalbs	; Return ALV size in bytes
		xor	cx, cx

cpm_space_loop:				; CODE XREF: DRV_SPACE+23j
		lodsb

cpm_space_ctbit:			; CODE XREF: DRV_SPACE+20j
		or	al, al
		jz	cpm_space_next

cpm_space_ckbit:			; CODE XREF: DRV_SPACE+1Dj
		shr	al, 1
		jnb	cpm_space_ckbit
		inc	cx
		jmps	cpm_space_ctbit
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_space_next:				; CODE XREF: DRV_SPACE+19j
		dec	bx
		jnz	cpm_space_loop	; CX = count of	used blocks
		mov	bx, dpb_dsm
		inc	bx
		sub	bx, cx		; BX = count of	free blocks
		mov	cl, dpb_bsh
		xor	ch, ch
		mov	al, bh
		xor	ah, ah
		shl	bx, cl		; Convert to records
		shl	ax, cl
		mov	di, userdma
		push	ds
		mov	ds, userdmaseg
		mov	[di], bx
		mov	2[di],	ah
		pop	ds
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

DRV_FLUSH:		; CODE XREF: DRV_ALLRESET+1Fj
					; DATA XREF: bdos:25BCo
		cmp	fs_function, 15h
		jz	flush0		; Function 98 entry point
		mov	al, 0Ch		; XIOS flush
		call	fs_call_xios
		call	diocomp

flush0:					; CODE XREF: DRV_FLUSH+5j
					; DATA XREF: bdos:25BFo ...
		mov	bx, login_vector; Function 98 entry point
		mov	dl, 10h

flush1:					; CODE XREF: DRV_FLUSH+1Dj
		dec	dl
		shl	bx, 1
		jb	flush2a

flush5:					; CODE XREF: DRV_FLUSH+74j
		or	bx, bx
		jnz	flush1
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

flush2a:				; CODE XREF: DRV_FLUSH+19j
		push	bx
		push	dx
		call	tmpselect_dir
		cmp	fs_function, 1Bh; Flush	or reset allocation?
		jnz	flush_not3
		call	not_drv_logged
		jz	ptsync_drvfail
		call	copy$alv
		jmps	flush4
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

ptsync_drvfail:				; CODE XREF: DRV_FLUSH+2Fj
		mov	byte ptr aret, 0FFh
		jmps	flush4
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

flush_not3:				; CODE XREF: DRV_FLUSH+2Aj
		cmp	fs_function, 15h
		jz	flush35
		cmp	fs_function, 23h
		jz	flush34
		call	flushx
		cmp	linfo, 0FFh	; Discard buffers?
		jnz	flush4
		jmps	flush35
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

flush34:				; CODE XREF: DRV_FLUSH+49j
		push	ds
		mov	ds, rlr

		mov	proc_using_drvs, 0
		pop	ds

		call	not_drv_logged
		jz	flush35
		call	copy$alv

flush35:				; CODE XREF: DRV_FLUSH+42j
					; DRV_FLUSH+55j ...
		mov	bx, dph_dtabcb
		call	proc$discard	; Free BCBs on bcb_drive used by current process

flush4:					; CODE XREF: DRV_FLUSH+34j
					; DRV_FLUSH+3Bj ...
		pop	dx
		pop	bx
		jmp	flush5



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

call_xios_flush:		; CODE XREF: F_CLOSE+3Ap fat_close+43p
		mov	al, 0Ch
		call	fs_call_xios
		call	diocomp



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

flushx:		; CODE XREF: check$nprs+100p
					; DRV_FLUSH+4Bp ...
		test	dpb_phm, 0FFh
		jnz	flushx1

flushxret:				; CODE XREF: trunc_save_dcnt+5j
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

flushx1:				; CODE XREF: flushx+5j
		mov	ah, 4
		jmp	deblock$dta



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

trunc_save_dcnt:		; CODE XREF: F_TRUNCATE+68p
					; F_TRUNCATE+90p
		cmp	byte ptr xdcnt+1, 0FDh
		jnz	flushxret
		jmp	save$dcnt$pos0



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_TRUNCATE:		; DATA XREF: bdos:25C2o
		call	copy8fromdma
		call	sel1_fcb_drive
		call	check$wild
		cmp	F_isfatfs, 0
		jz	cpm_truncate
		jmp	fat_truncate
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_truncate:				; CODE XREF: F_TRUNCATE+Ej
		call	chk$password
		jz	cpm_truncate0
		call	chk$pw$error

cpm_truncate0:				; CODE XREF: F_TRUNCATE+16j
		call	get$atts
		mov	cl, 0FFh
		call	cpm_rwrand	; CL=-1	read  0	write
		jz	cpm_truncate2

cpm_truncate1:				; CODE XREF: F_TRUNCATE+37j
					; F_TRUNCATE+3Cj
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_truncate2:				; CODE XREF: F_TRUNCATE+23j
		call	seek$copy
		call	getdptra
		mov	dx, 0Fh
		call	extent_size	; Convert a size (extent + record no)
					; to a 3-byte record number.
		call	compare_recno
		jbe	cpm_truncate1
		call	search$extnum	; Find any extent of a file
		jz	cpm_truncate1
		call	check$rodir
		mov	byte ptr xdcnt+1, 0FDh

cpm_truncate3:				; CODE XREF: F_TRUNCATE+88j
		call	getdptra
		add	bx, 0Ch
		mov	si, offset user_fcb+0Ch
		mov	al, 2[si]
		and	al, 3Fh
		cmp	2[bx],	al
		jnz	cpm_truncate4
		mov	al, [bx]
		mov	cl, [si]
		call	compext		; Compare extent nos in	AL and CL
					; Return nonzero if they do not	match
		jz	cpm_truncate4
		mov	al, [bx]
		cmp	al, cl

cpm_truncate4:				; CODE XREF: F_TRUNCATE+57j
					; F_TRUNCATE+60j
		jnb	cpm_truncate5
		call	trunc_save_dcnt
		jmps	trunc2
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_truncate5:				; CODE XREF: F_TRUNCATE+66j
		pushf	
		mov	cl, 0
		call	scandm$ab
		push	cs
		call	f_interrupt
		jz	trunc3
		call	getdptra
		mov	byte ptr [bx], 0E5h
		call	seek$copy
		call	fix$hash

trunc2:					; CODE XREF: F_TRUNCATE+6Bj
					; F_TRUNCATE+FEj
		call	searchn		; Search for the next directory	element,
					; assuming a previous call on search
		jnz	cpm_truncate3
		call	update$stamp
		jmp	copy$dir$loc
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

trunc3:					; CODE XREF: F_TRUNCATE+77j
		call	trunc_save_dcnt
		call	getfcb		; Set variables	from currently addressed FCB
		call	dm$position
		inc	al
		test	single,	0FFh	; Nonzero if using 8-bit blocks
		jnz	trunc3a
		shl	al, 1

trunc3a:				; CODE XREF: F_TRUNCATE+A0j
		mov	di, offset user_fcb+10h
		xor	ah, ah
		add	di, ax
		mov	cl, 10h
		sub	cl, al
		mov	ch, ah
		mov	al, ah
		rep stosb
		call	get$dir$ext	; Compute directory extent from	FCB
		cmp	al, [bx]
		mov	[bx], al
		pushf	
		mov	al, user_fcb+20h
		inc	al
		mov	si, offset user_fcb+0Fh
		mov	[si], al
		push	cs
		call	f_interrupt
		jz	trunc3b
		call	set$rc3

trunc3b:				; CODE XREF: F_TRUNCATE+CBj
		test	dminx, 0FFh
		jnz	trunc3c
		call	set$rc3

trunc3c:				; CODE XREF: F_TRUNCATE+D5j
		call	getdptra
		add	bx, 0Bh
		and	byte ptr [bx], 7Fh
		mov	al, user_fcb+0Ch
		mov	1[bx],	al
		add	bx, 4
		mov	si, offset user_fcb+0Fh
		mov	di, bx
		mov	cx, 11h
		rep movsb
		mov	cl, 1
		call	scandm$ab
		call	seek$copy
		jmp	trunc2



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

DRV_SETLABEL:		; DATA XREF: bdos:25C5o
		mov	cl, 10h
		call	copyfromdma
		call	sel1_fcb_drive
		cmp	F_isfatfs, 0
		jz	cpm_setlabel
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_setlabel:				; CODE XREF: DRV_SETLABEL+Dj
		mov	user_fcb, 21h	; Datestamped?
		mov	cl, 1
		call	search
		jnz	sdl0
		mov	bx, offset user_fcb+0Ch
		test	byte ptr [bx], 70h
		jz	sdl0
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

sdl0:					; CODE XREF: DRV_SETLABEL+1Cj
					; DRV_SETLABEL+24j
		mov	user_fcb, 20h
		mov	cl, 1
		mov	xdcnt, 0FFFFh
		call	search
		jnz	sdl1
		mov	make$xfcb, 0FFh
		call	make
		jnz	sdl0a
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

sdl0a:					; CODE XREF: DRV_SETLABEL+43j
		call	init$xfcb
		mov	cx, 18h
		call	stamp5
		call	stamp1

sdl1:					; CODE XREF: DRV_SETLABEL+39j
		mov	cx, 1Ch
		call	stamp5
		call	stamp2
		call	chk_xfcb_passwd
		jz	sdl1a
		jmp	pw$error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

sdl1a:					; CODE XREF: DRV_SETLABEL+5Ej
		xor	cx, cx
		call	init$xfcb0
		mov	si, dx
		lodsb
		or	al, 1
		mov	[bx], al
		mov	di, lsn$add
		stosb



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

sdl2:		; CODE XREF: F_WRITEXFCB+5Fp
		dec	si
		lodsb
		and	al, 1
		jz	sdl3
		mov	si, offset passwd_buf+8
		call	set$pw



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

sdl3:		; CODE XREF: F_MAKE+D1p sdl2+4j
					; ...
		call	seek$copy
		jmp	fix$hash



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

DRV_GETLABEL:		; DATA XREF: bdos:25C8o
		call	tmpselect_dir
		cmp	F_isfatfs, 0
		jz	cpm_getlabel
		mov	al, 21h		; FAT filesystems always use 21h
		jmp	sta$ret
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_getlabel:				; CODE XREF: DRV_GETLABEL+8j
		call	get$dir$mode
		jmp	sta$ret



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_TIMEDATE:		; DATA XREF: bdos:25CBo
		call	sel1_fcb_drive
		call	check$wild
		cmp	F_isfatfs, 0
		jz	cpm_timedate
		jmp	fat_timedate
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_timedate:				; CODE XREF: F_TIMEDATE+Bj
		call	find_extent_0	; Find the first extent	of a file
		jz	wxfcb0a
		mov	ch, 0
		call	get$dtba
		or	al, al
		jnz	cpm_timedate1
		push	bx
		mov	di, offset user_fcb+10h
		mov	cx, 8
		rep stosb
		pop	si
		mov	cl, 4
		rep movsw
		lodsb
		mov	user_fcb+0Ch, al
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_timedate1:				; CODE XREF: F_TIMEDATE+1Cj
		call	get$xfcb
		mov	al, 0FFh
		jnz	cpm_timedate2
		jmp	sta$ret
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_timedate2:				; CODE XREF: F_TIMEDATE+36j
		mov	bx, offset user_fcb
		mov	cl, 20h
		jmp	move		; Copy CL bytes	from DX	to BX



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_WRITEXFCB:		; DATA XREF: bdos:25CEo
		mov	cl, 10h
		call	copyfromdma
		call	sel1_fcb_drive
		cmp	F_isfatfs, 0
		jz	cpm_wrxfcb
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_wrxfcb:				; CODE XREF: F_WRITEXFCB+Dj
		call	get$dir$mode
		and	al, 80h
		jnz	wxfcb0
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

wxfcb0:					; CODE XREF: F_WRITEXFCB+17j
		call	check$wild
		mov	xdcnt, 0FFFFh
		call	search$extnum	; Find any extent of a file
		jnz	wxfcb0b

wxfcb0a:				; CODE XREF: F_TIMEDATE+13j
					; F_WRITEXFCB+36j ...
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

wxfcb0b:				; CODE XREF: F_WRITEXFCB+28j
		call	get$xfcb
		jnz	wxfcb1
		mov	make$xfcb, al
		call	make
		jz	wxfcb0a
		call	init$xfcb

wxfcb1:					; CODE XREF: F_WRITEXFCB+2Ej
		call	chk_xfcb_passwd
		jz	wxfcb1a
		jmp	pw$error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

wxfcb1a:				; CODE XREF: F_WRITEXFCB+3Ej
		mov	si, offset user_fcb+0Ch
		test	byte ptr [bx], 0FFh
		jnz	wxfcb2
		lodsb
		dec	si
		and	al, 1
		jnz	wxfcb2
		call	sdl3
		jmps	wxfcb4
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

wxfcb2:					; CODE XREF: F_WRITEXFCB+49j
					; F_WRITEXFCB+4Fj
		lodsb
		and	al, 0E0h
		jnz	wxfcb3
		mov	al, 80h

wxfcb3:					; CODE XREF: F_WRITEXFCB+59j
		mov	[bx], al
		call	sdl2

wxfcb4:					; CODE XREF: F_WRITEXFCB+54j
		call	get$xfcb1
		and	al, 0E0h
		mov	pw$mode, al	; Password mode
		push	ax
		call	find_extent_0	; Find the first extent	of a file
		pop	ax
		mov	user_fcb+0Ch, al
		jz	wxfcb0a
		call	get$dtba$8
		or	al, al
		jnz	wxfcb0a
		mov	al, pw$mode	; Password mode
		mov	[bx], al
		jmp	seek$copy



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_PASSWD:		; DATA XREF: bdos:25D1o
		mov	cl, 8
		call	copy_fcb
		mov	cur_fcb_len, 0
		mov	si, offset user_fcb
		mov	bx, si
		mov	di, offset df$password+7; Default password
		mov	cx, 8
		jmp	set$pw0



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_BDOS_74:		; DATA XREF: bdos:25D4o
		call	check_changed
		call	copy8fromdma
		call	check$write
		cmp	F_isfatfs, 0
		jz	cpm_bdos_74
		jmp	fat_bdos_74
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_bdos_74:				; CODE XREF: F_BDOS_74+Ej
		mov	ah, user_fcb+0Ch
		mov	al, user_fcb+0Eh
		push	ax
		call	find_extent_0	; Find the first extent	of a file
		pop	ax
		mov	user_fcb+0Ch, ah
		mov	user_fcb+0Eh, al
		jz	cpm_74b
		mov	cl, 50h
		call	qstamp
		jnz	cpm_74a
		mov	ch, 0
		call	get$dtba
		or	al, al
		jnz	cpm_74a
		mov	dx, offset passwd_buf
		call	stamp_compare

cpm_74a:				; CODE XREF: F_BDOS_74+2Dj
					; F_BDOS_74+36j
		mov	cl, 20h
		call	qstamp
		jnz	cpm_74b
		mov	ch, 4
		call	get$dtba
		or	al, al
		jnz	cpm_74b
		mov	dx, offset passwd_buf+4
		call	stamp_compare
		or	user_fcb+0Eh, 40h

cpm_74b:				; CODE XREF: F_BDOS_74+26j
					; F_BDOS_74+43j ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_BDOS_75:		; DATA XREF: bdos:25DAo
		mov	si, dx
		mov	di, offset int13_func
		push	ds
		mov	ds, fs_param_ds
		mov	cx, 0Ah
		rep movsb
		pop	ds
		mov	dl, int13_drive
		call	tmpselect_dir
		call	flushx
		mov	ax, word ptr int13_buffer+2
		mov	word ptr fs_buffer, ax
		mov	ax, word ptr int13_buffer
		mov	word ptr fs_buffer+2, ax
		mov	al, int13_sectors
		mov	fs_rdwrcount, al
		cmp	int13_func, 3
		jnb	bdos75c
		xor	ah, ah
		mov	al, int13_sector
		mov	fs_sector, ax
		mov	ah, int13_head
		mov	al, int13_cylinder
		mov	fs_track, ax
		cmp	int13_func, 0
		jnz	bdos75_notread
		mov	al, 23h
		call	xios_rdwr
		mov	aret, ax
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

bdos75_notread:				; CODE XREF: F_BDOS_75+4Aj
		cmp	int13_func, 1
		jnz	bdos75_notwrite
		call	discard$both
		mov	al, 24h
		call	xios_rdwr
		mov	aret, ax
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

bdos75_notwrite:			; CODE XREF: F_BDOS_75+5Aj
		mov	fs_rdwrcount, 1
		mov	si, dph_dirbcb
		mov	si, [si]

bdos75a:				; CODE XREF: F_BDOS_75+81j
		cmp	byte ptr [si], 0FFh
		jz	bdos75b
		mov	bx, 12[si]
		or	bx, bx
		jz	bdos75b
		mov	si, bx
		jmps	bdos75a
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

bdos75b:				; CODE XREF: F_BDOS_75+76j
					; F_BDOS_75+7Dj
		mov	byte ptr [si], 0FFh
		mov	ax, 10[si]
		mov	word ptr fs_buffer+2, ax
		mov	word ptr fs_buffer, ds
		mov	al, 23h
		call	xios_rdwr
		mov	aret, ax
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

bdos75c:				; CODE XREF: F_BDOS_75+31j
		mov	ax, word ptr int13_sector
		xor	dx, dx
		div	dpb_spt
		mov	fs_track, ax
		mov	fs_sector, dx
		cmp	int13_func, 4
		jz	bdos75d
		mov	al, 0Ah
		call	xios_rdwr
		mov	aret, ax
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

bdos75d:				; CODE XREF: F_BDOS_75+AEj
		call	discard$both
		mov	al, 0Bh
		call	xios_rdwr
		mov	aret, ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

discard$both:		; CODE XREF: F_BDOS_75+5Cp
					; F_BDOS_75+B9p
		mov	bx, dph_dtabcb
		call	discard$data	; Called with BX->BCB chain head. Release all BCBs for a drive
		jmp	discard$dir	; Release all directory	BCBs for a drive


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ
log$fxs		db 0Ch,	2, 3, 4, 6, 9, 0Ah, 0Dh, 11h, 1Ch, 1Dh,	1Fh, 20h
		db 0,0,0,0
					; DATA XREF: tst$log$fxs+7o
rw$fxs		db 5, 7, 8, 0Fh, 10h, 16h, 0, 0
					; Read or write	functions
sc$fxs		db 2, 3, 5, 0, 0
					; Close	or search functions

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

srch_fat:		; CODE XREF: F_SFIRST+41j
		popf	
		pushf	
		jnz	srch_fat1
		call	set$end$dir
		mov	ff2c_extent, 0

srch_fat1:				; CODE XREF: srch_fat+2j
		cmp	cl, 0
		jz	srch_fat2
		mov	bx, offset user_fcb+0Ch
		cmp	byte ptr [bx], 3Fh
		mov	cl, 2
		jz	srch_fat2
		mov	cl, 3
		mov	al, [bx]
		xor	ah, ah
		mov	ff2c_extent, ax

srch_fat2:				; CODE XREF: srch_fat+10j srch_fat+1Aj
		cmp	cl, 3
		jnb	srch_fat3
		test	ff2c_extent, 0FFFFh
		jz	srch_fat3
		dec	dcnt

srch_fat3:				; CODE XREF: srch_fat+28j srch_fat+30j
		mov	searchl, cl

srch_fat4:				; CODE XREF: srch_fat+5Fj srch_fat+6Ej
					; ...
		mov	cl, searchl
		xor	ch, ch
		call	fat_search1
		or	ax, ax
		jnz	srch_fat5
		popf	
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

srch_fat5:				; CODE XREF: srch_fat+45j
		cmp	searchl, 2
		jb	srch_fat6
		mov	bx, ax
		test	byte ptr 11[bx], 10h
		jz	srch_fat6
		test	fcb_is_for_dir,	0FFh
		jz	srch_fat4

srch_fat6:				; CODE XREF: srch_fat+50j srch_fat+58j
		cmp	searchl, 3
		jnz	srch_fat7
		call	fat_extents
		cmp	ax, 0FFFFh
		jz	srch_fat4

srch_fat7:				; CODE XREF: srch_fat+66j
		popf	
		jnz	srch_fat8
		cmp	searchl, 0
		jnz	srch_fat8
		jmp	srch_fat12
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

srch_fat8:				; CODE XREF: srch_fat+71j srch_fat+78j
		pushf	
		mov	bx, p_dirent
		test	byte ptr 11[bx], 8
		jnz	srch_fat4
		popf	
		push	es
		mov	es, userdmaseg
		mov	di, userdma
		mov	bx, p_dirent
		cmp	byte ptr [bx], 0
		jz	srch_fat9
		cmp	byte ptr [bx], 0E5h
		jnz	srch_fat10

srch_fat9:				; CODE XREF: srch_fat+99j
		mov	al, 0E5h
		stosb
		xor	ax, ax
		mov	cx, 7Fh
		rep stosb
		jmps	srch_fat11
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

srch_fat10:				; CODE XREF: srch_fat+9Ej
		call	fat_extents
		xor	bx, bx
		push	bx
		push	ax
		push	di
		call	fat_fcb_to_cpm
		pop	di
		pop	bx
		pop	ax
		add	di, 20h
		mov	cx, 20h
		rep stosw
		call	fat_to_sfcb	; Generate a fake CP/M SFCB [datestamp]	record
		inc	ff2c_extent
		call	fat_extents
		cmp	ax, 0FFFFh
		jnz	srch_fat11
		mov	ff2c_extent, 0

srch_fat11:				; CODE XREF: srch_fat+AAj srch_fat+CFj
		pop	es
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

srch_fat12:				; CODE XREF: srch_fat+7Aj srch_fat+F4j
		mov	bx, p_dirent
		mov	al, [bx]
		cmp	al, 0
		jz	srch_fat15
		cmp	al, 0E5h
		jz	srch_fat13
		test	byte ptr 11[bx], 8
		jnz	srch_fat14

srch_fat13:				; CODE XREF: srch_fat+E5j
		sub	cx, cx
		call	fat_search1
		test	bx, bx
		jnz	srch_fat12
		jmps	srch_fat15
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

srch_fat14:				; CODE XREF: srch_fat+EBj
		mov	es, userdmaseg
		mov	di, userdma
		mov	al, 20h
		stosb
		lea	si, [bx]
		mov	cx, 0Bh
		rep movsb
		jmps	srch_fat16
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

srch_fat15:				; CODE XREF: srch_fat+E1j srch_fat+F6j
		mov	es, userdmaseg
		mov	di, userdma
		mov	al, 20h
		mov	cx, 0Ch
		rep stosb

srch_fat16:				; CODE XREF: srch_fat+10Aj
		push	es
		push	di
		push	ds
		pop	es

		call	set$end$dir
		sub	cx, cx
		call	fat_search1
		pop	di
		pop	es

		mov	al, 21h
		stosb
		xor	ax, ax
		stosw
		mov	al, 80h
		stosb
		stosb
		stosb
		xor	ax, ax
		mov	cx, 27h
		rep stosw
		mov	al, 21h
		stosb
		xor	al, al
		mov	cx, 1Fh
		rep stosb
		push	ds
		pop	es

		test	byte ptr 11[bx], 8
		jnz	srch_fatret
		jmp	set$end$dir
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

srch_fatret:				; CODE XREF: srch_fat+14Bj
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

c2f_to_extent:		; CODE XREF: fat_rdwr+363p
		xor	ah, ah
		mov	al, c2f_S2
		mov	cl, 5
		shl	ax, cl
		or	al, c2f_EX
		mov	ff2c_extent, ax
		mov	ax, word ptr user_fcb+1Ch
		mov	dx, word ptr user_fcb+1Eh
		jmps	size_to_cpm



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_extents:		; CODE XREF: srch_fat+68p srch_fat+ACp
					; ...
		mov	bx, p_dirent
		mov	ax, 28[bx]
		mov	dx, 30[bx]	; File size

size_to_cpm:				; CODE XREF: c2f_to_extent+17j
		mov	bx, ax
		mov	cl, 0Eh
		call	shr_dxax_cl	; Size in extents
		and	bx, 3FFFh
		or	bx, bx		; Size in current extent
		jnz	size_ok
		or	ax, ax
		jz	size_ok
		dec	ax
		mov	bx, 4000h	; Round	up

size_ok:				; CODE XREF: fat_extents+17j
					; fat_extents+1Bj
		cmp	ax, ff2c_extent
		jnb	fat_exte2
		mov	ax, 0FFFFh
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_exte2:				; CODE XREF: fat_extents+25j
		ja	fat_exte3
		mov	ax, bx
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_exte3:				; CODE XREF: fat_extents+2Bj
		mov	ax, 4000h
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_fcb_to_cpm:		; CODE XREF: srch_fat+B4p cpm_opendir+16Dp
					; ...
		push	bp
		mov	bp, sp
		mov	di, 4[bp]
		test	word ptr 8[bp], 0FFFFh
		jnz	ff2c_skipuser
		mov	al, usrcode	; User ID
		mov	es:[di], al

ff2c_skipuser:				; CODE XREF: fat_fcb_to_cpm+Bj
		xor	bx, bx
		mov	si, p_dirent

ff2c_copyname:				; CODE XREF: fat_fcb_to_cpm+63j
		cmp	bl, 0Bh
		jnb	ff2c_namedone
		xor	al, al
		cmp	bl, 4
		ja	ff2c_notFattr
		mov	al, 12[si]
		mov	cl, bl		; Generate F1-F4 from dir entry
		shl	al, cl
		and	al, 80h
		jmps	ff2c_notT3
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

ff2c_notFattr:				; CODE XREF: fat_fcb_to_cpm+23j
		cmp	bl, 8
		jnz	ff2c_notT1
		test	byte ptr 11[si], 1; R/O
		jz	ff2c_notT3
		jmps	ff2c_haveattr
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

ff2c_notT1:				; CODE XREF: fat_fcb_to_cpm+33j
		cmp	bl, 9
		jnz	ff2c_notT2
		test	byte ptr 11[si], 4; SYS
		jz	ff2c_notT3
		jmps	ff2c_haveattr
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

ff2c_notT2:				; CODE XREF: fat_fcb_to_cpm+40j
		cmp	bl, 0Ah
		jnz	ff2c_notT3	; ARCV
		test	byte ptr 11[si], 20h
		jnz	ff2c_notT3

ff2c_haveattr:				; CODE XREF: fat_fcb_to_cpm+3Bj
					; fat_fcb_to_cpm+48j
		mov	al, 80h

ff2c_notT3:				; CODE XREF: fat_fcb_to_cpm+2Ej
					; fat_fcb_to_cpm+39j
					; ...
		mov	dl, [bx+si]
		and	dl, 7Fh
		or	dl, al
		mov	es:1[bx+di], dl
		inc	bx
		jmps	ff2c_copyname
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

ff2c_namedone:				; CODE XREF: fat_fcb_to_cpm+1Cj
		mov	ax, ff2c_extent
		and	ax, 1Fh
		mov	es:12[di], al	; Extent, low bits
		mov	ax, 6[bp]
		mov	dl, al
		and	dl, 7Fh
		shl	ax, 1
		mov	al, dl
		or	al, al
		jz	ff2c_bytesize
		inc	ah

ff2c_bytesize:				; CODE XREF: fat_fcb_to_cpm+7Dj
		test	word ptr 8[bp], 0FFFFh
		jnz	ff2c_S2
		mov	es:13[di], al	; File size

ff2c_S2:				; CODE XREF: fat_fcb_to_cpm+86j
		mov	bx, ff2c_extent
		mov	cl, 5
		shr	bx, cl
		mov	es:14[di], bl	; Extent, high
		mov	es:15[di], ah
		mov	al, 80h		; Flags	for bytes 16/17
		test	byte ptr 11[si], 10h;	Directory?
		jz	ff2c_isdir
		or	al, 40h		; Bit 6	=> dir

ff2c_isdir:				; CODE XREF: fat_fcb_to_cpm+A2j
		test	byte ptr 11[si], 2
		jz	ff2c_hid
		or	al, 20h		; Bit 5	=> hidden

ff2c_hid:				; CODE XREF: fat_fcb_to_cpm+AAj
		mov	bx, dcnt
		or	al, bh
		mov	es:16[di], al
		mov	es:17[di], al
		mov	es:18[di], bl
		xor	ax, ax
		mov	es:19[di], al
		mov	es:20[di], ax
		lea	di, 22[di]
		lea	si, 22[si]
		mov	cx, 5
		rep movsw
		pop	bp
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Generate a fake CP/M SFCB [datestamp]	record

fat_to_sfcb:		; CODE XREF: srch_fat+C2p
		mov	al, 21h
		stosb
		mov	bx, p_dirent
		mov	ax, 24[bx]
		mov	bx, 22[bx]	; Got a	DOS datestamp?
		or	ax, bx
		jnz	f2sfcb_1
		mov	cx, 1Fh
		rep stosb
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

f2sfcb_1:				; CODE XREF: fat_to_sfcb+Fj
		call	fat_get_date
		call	dos_date_to_cpm
		xor	ax, ax
		stosw
		stosw
		mov	si, offset fs_days
		movsw
		movsw
		mov	cx, 15h
		rep stosb
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_get_date:		; CODE XREF: fat_to_sfcb+17p
					; fat_timedate+14p
		mov	bx, p_dirent
		mov	ax, 24[bx]
		mov	dl, al
		and	dl, 1Fh
		mov	fat_year, dl
		mov	cl, 5
		shr	ax, cl
		mov	dl, al
		and	dl, 0Fh
		mov	fat_month, dl
		mov	cl, 4
		shr	ax, cl
		mov	fat_day, al
		mov	ax, 22[bx]
		mov	dl, al
		and	dl, 1Fh
		mov	fat_second, dl
		mov	cl, 5
		shr	ax, cl
		mov	dl, al
		and	dl, 3Fh
		mov	fat_minute, dl
		mov	cl, 6
		shr	ax, cl
		mov	fat_hour, al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_set_date:		; CODE XREF: fat_make+93p fat_make+100p
					; ...
		mov	bx, p_dirent
		mov	al, fat_day
		mov	cl, 4
		shl	ax, cl
		add	al, fat_month
		mov	cl, 5
		shl	ax, cl
		add	al, fat_year
		mov	24[bx], ax
		mov	al, fat_hour
		mov	cl, 6
		shl	ax, cl
		add	al, fat_minute
		mov	cl, 5
		shl	ax, cl
		add	al, fat_second
		mov	22[bx], ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

dos_date_to_cpm:		; CODE XREF: fat_to_sfcb+1Ap
					; fat_timedate+17p
		xor	bx, bx
		mov	bl, fat_month
		dec	bx
		add	bx, bx
		mov	ax, monthDays[bx]
		push	ax
		xor	ah, ah
		mov	al, fat_day
		inc	ax
		inc	ax
		mov	bx, 365
		mul	bx
		pop	bx
		add	ax, bx
		xor	bx, bx
		mov	bl, fat_year
		add	ax, bx
		push	ax
		mov	bl, fat_month
		xor	bh, bh
		mov	al, fat_day
		add	al, 4
		xor	ah, ah
		call	leap_year_test
		pop	bx
		add	ax, bx
		mov	fs_days, ax
		mov	al, fat_hour
		call	pack_bcd
		mov	fs_hours, al
		mov	al, fat_minute
		call	pack_bcd
		mov	fs_minutes, al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_today:		; CODE XREF: fat_make+90p fat_truncate+96p
		mov	si, offset date_days
		mov	di, offset fs_days
		mov	cx, 5
		rep movsb



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

timestamp_2_fat:		; CODE XREF: fat_bdos_74+15p
		mov	cx, offset rlr
		mov	bx, fs_days
		dec	bx

ts2fat_year1:				; CODE XREF: timestamp_2_fat+18j
		mov	dx, 365
		test	cl, 3
		jnz	ts2fat_noleap
		inc	dx

ts2fat_noleap:				; CODE XREF: timestamp_2_fat+Ej
		cmp	bx, dx
		jb	ts2fat_nextyear
		sub	bx, dx
		inc	cx
		jmps	ts2fat_year1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

ts2fat_nextyear:			; CODE XREF: timestamp_2_fat+13j
		xor	dx, dx
		test	cl, 3
		jnz	ts2fat_feb
		cmp	bx, 59
		jbe	ts2fat_feb
		mov	dx, 1

ts2fat_feb:				; CODE XREF: timestamp_2_fat+1Fj
					; timestamp_2_fat+24j
		mov	si, 18h

tst2fat_months1:			; CODE XREF: timestamp_2_fat+3Aj
		dec	si
		dec	si
		or	si, si
		jz	ts2fat_months2
		mov	ax, monthDays[si]
		add	ax, dx
		cmp	ax, bx
		ja	tst2fat_months1

ts2fat_months2:				; CODE XREF: timestamp_2_fat+30j
		sub	cx, 50h
		mov	fat_day, cl
		mov	ax, si
		shr	al, 1
		inc	al
		mov	fat_month, al
		mov	ax, monthDays[si]
		sub	bx, ax
		sub	bx, dx
		inc	bl
		mov	fat_year, bl
		mov	al, fs_hours
		call	bcd2bin
		mov	fat_hour, al
		mov	al, fs_minutes
		call	bcd2bin
		mov	fat_minute, al
		mov	al, fs_seconds
		call	bcd2bin
		shr	al, 1
		mov	fat_second, al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

leap_year_test:		; CODE XREF: dos_date_to_cpm+33p
		mov	dx, ax
		shr	ax, 1
		shr	ax, 1
		test	dx, 3
		jnz	lyt_ret
		dec	bx
		add	bx, bx
		mov	bx, monthDays[bx]
		cmp	bx, 59
		jnb	lyt_ret
		dec	ax

lyt_ret:				; CODE XREF: leap_year_test+Aj
					; leap_year_test+16j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

pack_bcd:		; CODE XREF: dos_date_to_cpm+3Fp
					; dos_date_to_cpm+48p
		xor	ah, ah

pack_b1:				; CODE XREF: pack_bcd+Bj
		cmp	al, 0Ah
		jb	pack_b2
		sub	al, 0Ah
		add	ah, 10h
		jmps	pack_b1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

pack_b2:				; CODE XREF: pack_bcd+4j
		add	al, ah
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

bcd2bin:		; CODE XREF: timestamp_2_fat+5Dp
					; timestamp_2_fat+66p
					; ...
		xor	ah, ah

bcd2bin1:				; CODE XREF: bcd2bin+Bj
		cmp	al, 10h
		jb	bcd2bin2
		sub	al, 10h
		add	ah, 0Ah
		jmps	bcd2bin1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

bcd2bin2:				; CODE XREF: bcd2bin+4j
		add	al, ah
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

lookup_dirent:		; CODE XREF: fat_open+1Fp fat_close+22p
					; ...
		call	set$end$dir



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_dirent_next:		; CODE XREF: fat_delete+10p
					; fat_delete+96p ...
		mov	cx, 2



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_search1:		; CODE XREF: srch_fat+40p srch_fat+EFp
					; ...
		push	cx
		call	read$subdir
		pop	cx
		mov	p_dirent, ax
		mov	bx, ax
		or	ax, ax
		jz	scd_4
		cmp	cl, 0
		jnz	scd_1

scd_retbx:				; CODE XREF: fat_search1+1Fj
					; fat_search1+23j
		mov	ax, bx
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

scd_1:					; CODE XREF: fat_search1+11j
		cmp	cl, 1
		jnz	scd_2
		mov	al, [bx]
		or	al, al
		jz	scd_retbx
		cmp	al, 0E5h
		jz	scd_retbx
		jmps	scd_next
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

scd_2:					; CODE XREF: fat_search1+19j
		push	bx
		call	get_cwd_cluster
		pop	bx
		jnz	scd_5
		mov	ax, dcnt
		mov	si, cdrmaxa
		cmp	ax, [si]
		jb	scd_5

scd_3:					; CODE XREF: fat_search1+45j
		xor	ax, ax
		mov	p_dirent, ax

scd_4:					; CODE XREF: fat_search1+Cj
		mov	bx, ax
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

scd_5:					; CODE XREF: fat_search1+2Cj
					; fat_search1+37j
		mov	al, [bx]
		or	al, al
		jz	scd_3
		cmp	al, 0E5h
		jz	scd_next
		test	byte ptr 11[bx], 8
		jnz	scd_next
		call	fat_matchname
		or	al, al
		jz	scd_next
		mov	ax, p_dirent
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

scd_next:				; CODE XREF: fat_search1+25j
					; fat_search1+49j ...
		jmp	fat_search1



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_matchname:		; CODE XREF: fat_search1+51p
		mov	al, ch
		push	cx
		xor	ah, ah
		mov	si, offset user_fcb+1
		add	si, ax
		mov	cx, 0Bh

fat_matchn1:				; CODE XREF: fat_matchname+23j
		mov	al, [si]
		xor	al, [bx]
		test	al, 7Fh
		jz	fat_matchn2
		mov	al, [si]
		xor	al, 3Fh
		test	al, 7Fh
		jz	fat_matchn2
		xor	al, al
		pop	cx
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_matchn2:				; CODE XREF: fat_matchname+13j
					; fat_matchname+1Bj
		inc	si
		inc	bx
		loop	fat_matchn1
		or	al, 1
		pop	cx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

shl_dxax_cl:		; CODE XREF: fat_truncate+2Fp
		xor	ch, ch

shl_loop:				; CODE XREF: shl_dxax_cl+6j
		shl	ax, 1
		rcl	dx, 1
		loop	shl_loop
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

shr_dxax_cl:		; CODE XREF: fat_extents+Ep
					; size_to_records+Fp
					; ...
		xor	ch, ch

shr_loop:				; CODE XREF: shr_dxax_cl+6j
		shr	dx, 1
		rcr	ax, 1
		loop	shr_loop
		retn	


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ
		mul	cx
		push	dx
		xchg	ax, bx
		mul	cx
		pop	dx
		add	ax, dx
		xchg	ax, bx
		retn	

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_muldiv:		; CODE XREF: fat_rdwr+CDp
		jcxz	fat_mdiv0
		cmp	cx, 1
		jnz	fat_mdiv1
		mov	dx, bx
		xor	cx, cx
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_mdiv1:				; CODE XREF: fat_muldiv+5j
		xor	dx, dx
		xchg	ax, bx
		push	ax
		div	cx
		mov	di, ax
		mul	cx
		pop	dx
		sub	dx, ax
		mov	ax, bx
		div	cx
		mov	cx, dx
		mov	dx, di
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_mdiv0:				; CODE XREF: fat_muldivj
		mov	ax, 0FFFFh
		mov	dx, ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_open:		; CODE XREF: F_OPEN+Dj
		mov	cl, 0C0h	; Get F5' and F6'
		call	get_sharemode
		test	fcb_is_for_dir,	0FFh
;
; Allow	open of	"." to work in the root directory even though it has
; no "." entry.
;
		jz	fat_open_notdot	; Not directory, so can't be '.'
		call	get_cwd_cluster
		jnz	fat_open_notdot	; Got cluster, so not the root
		cmp	user_fcb+1, '.'
		jnz	fat_open_notdot	; Not "."
		cmp	user_fcb+2, ' '
		jz	diropen_dot

fat_open_notdot:			; CODE XREF: fat_open+Aj fat_open+Fj
					; ...
		call	lookup_dirent
		or	ax, ax
		jnz	open_got_dirent
		test	fcb_is_for_dir,	0FFh
		jz	open_fail
		call	get_cwd_cluster
		jnz	open_fail



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

cpm_opendir:		; CODE XREF: F_OPEN+17p
		cmp	user_fcb+1, '.'
		jnz	open_fail
		cmp	user_fcb+2, ' '
		jnz	open_fail
;
; CP/M only allows the fake "."
;

diropen_dot:				; CODE XREF: fat_open+1Dj fat_close+12j
		mov	ax, offset user_fcb+2
		mov	p_dirent, ax
		mov	user_fcb+0Dh, 10h; Faux	"." entry for root
		mov	word ptr user_fcb+1Ch, 0
		jmps	open_got_dirent
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

open_fail:				; CODE XREF: fat_open+2Bj fat_open+30j
					; ...
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

open_got_dirent:			; CODE XREF: fat_open+24j cpm_opendir+1Fj
		test	fcb_is_for_dir,	0FFh
		jnz	opendir_got
		jmp	open_file
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

opendir_got:				; CODE XREF: cpm_opendir+29j
		xor	bx, bx
		mov	bl, user_fcb+0Ch; BL = 0 for current drive,
					;      1-3 to assign floating drive
		cmp	bl, 4
		jnb	open_fail
		mov	di, ax
		test	byte ptr 11[di], 10h
		jz	open_fail	; Not actually a directory
		or	bl, bl
		jz	opendir_setcwd
		add	bl, 0Ch
		jmps	assign_floatdrv
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

opendir_setcwd:				; CODE XREF: cpm_opendir+43j
		cmp	cur_drvdir, 0
		jz	chdir_fromroot
		mov	bl, chdir_drive
		jmps	assign_floatdrv
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

chdir_fromroot:				; CODE XREF: cpm_opendir+4Fj
		mov	bl, fcbdsk
		sub	bl, 1
		jnb	chdir_notfloat
		push	ds
		mov	ds, rlr

		mov	bl, proc_drive
		pop	ds

		jmps	assign_floatdrv
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

chdir_notfloat:				; CODE XREF: cpm_opendir+5Ej
		and	bl, 1Fh		; What?	You support drives >P:?
		cmp	bl, 0Dh
		jb	chdir_realdrv
		cmp	bl, 0Fh
		jbe	assign_floatdrv

chdir_realdrv:				; CODE XREF: cpm_opendir+72j
		mov	bl, fs_fcbdrive

assign_floatdrv:			; CODE XREF: cpm_opendir+48j
					; cpm_opendir+55j ...
		push	ds
		mov	ds, rlr

		mov	si, proc_dirname
		pop	ds

		or	si, si		; Do we	have a current-directory 
					; structure to hand?
		mov	dx, si		; If not, fine.
		jz	dn_released
		cmp	word ptr 32[si], 1
		jz	dn_ref_was_1	; If ref count is 1, take over the
					; record which has now become free.
		dec	word ptr 32[si]

dn_released:				; CODE XREF: cpm_opendir+8Bj
		pushf	
		cli	
		mov	si, free_dirnames; Need	a new dirname. Allocate	one.
		or	si, si
		jnz	got_new_dirname
		popf	
		jmps	disk_error_11
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

got_new_dirname:			; CODE XREF: cpm_opendir+9Ej
		mov	ax, [si]
		mov	free_dirnames, ax
		popf	
		push	es
		mov	es, rlr

		mov	es:proc_dirname, si
		pop	es
		or	dx, dx		; Are we copying an existing structure?
		jz	gnd_blank	; No. Init to blanks.
		mov	bp, si
		mov	di, si		; Yes. Copy the	template.
		mov	si, dx
		mov	cx, 12h
		rep movsw
		mov	si, bp
		jmps	gnd_inited
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

gnd_blank:				; CODE XREF: cpm_opendir+B6j
		xor	ax, ax
		mov	di, si
		mov	cx, 12h
		rep stosw

gnd_inited:				; CODE XREF: cpm_opendir+C5j
		mov	word ptr 32[si], 1; Set ref count to 1.

dn_ref_was_1:				; CODE XREF: cpm_opendir+91j
		add	bx, bx		; BX = drive ID
		add	si, bx
		mov	bx, [si]	; Is there a drvdir structure for
					; this drive?
		or	bx, bx
		jz	need_new_dirdat
		dec	word ptr 8[bx]	; Decrease ref count
		jz	got_dirdata	; If it	was one, take over the now-
					; empty	record.

need_new_dirdat:			; CODE XREF: cpm_opendir+DDj
		push	si
		call	dirdata_alloc
		pop	si
		jnz	got_dirdata

disk_error_11:				; CODE XREF: cpm_opendir+A1j
		mov	ah, 0Bh		; No room in system lock list
		jmp	disk_error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

got_dirdata:				; CODE XREF: cpm_opendir+E2j
					; cpm_opendir+E9j
		mov	[si], bx	; Point	dirname	structure at this drvdir
		mov	al, curdsk
		mov	[bx], al	; Drive
		mov	si, lsn$add
		mov	al, 2[si]
		mov	1[bx],	al	; Filesystem type
		mov	di, p_dirent
		mov	dx, 26[di]
		cmp	dx, dname_cluster
		jnz	not_opening_dot
		mov	si, cur_drvdir
		or	si, si
		jz	not_opening_dot
		mov	ax, 2[si]	; If opening ".", just keep what we 
					; had before.
		mov	cx, 4[si]
		jmps	setup_dirdata
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

not_opening_dot:			; CODE XREF: cpm_opendir+10Cj
					; cpm_opendir+114j
		mov	ax, dname_cluster
		mov	cx, dcnt

setup_dirdata:				; CODE XREF: cpm_opendir+11Cj
		mov	2[bx],	ax	; Parent cluster
		mov	4[bx],	cx	; Offset of entry in parent dir?
		mov	6[bx],	dx	; Cluster of directory
		mov	word ptr 8[bx], 1
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

open_file:				; CODE XREF: cpm_opendir+2Bj
		mov	bx, ax
		test	byte ptr 11[bx], 10h
		jz	open_file1
		jmp	open_fail
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

open_file1:				; CODE XREF: cpm_opendir+13Aj
		cmp	attributes, 80h	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		jnz	open_file2
		test	byte ptr 11[bx], 1
		jz	open_file2
		mov	attributes, 20h	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'

open_file2:				; CODE XREF: cpm_opendir+144j
					; cpm_opendir+14Aj
		mov	al, user_fcb+0Ch
		and	al, 1Fh
		xor	ah, ah
		mov	ff2c_extent, ax
		call	fat_extents
		cmp	ax, 0FFFFh
		jnz	open_file3
		inc	ax

open_file3:				; CODE XREF: cpm_opendir+161j
		mov	bx, 0FFFFh
		push	bx
		push	ax
		mov	bx, offset user_fcb
		push	bx
		call	fat_fcb_to_cpm
		add	sp, 6
		cmp	user_fcb+20h, 0FFh
		jnz	open_file4
		mov	bx, p_dirent
		mov	al, 28[bx]
		and	al, 7Fh
		mov	user_fcb+20h, al

open_file4:				; CODE XREF: cpm_opendir+178j
		or	user_fcb+0Eh, 80h
		mov	open_G01, 0FFh
		jmp	openx1a



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fs_noop:		; CODE XREF: fat_close+36p
					; fat_make+13Bp
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get_sharemode:		; CODE XREF: fat_open+2p fat_make+2p
		push	cx
		call	get$atts
		pop	cx
		and	al, cl
		cmp	al, 0C0h	; Get sharing mode.
					; If F5' and F6' set, F6' wins.
		jnz	gsm_1
		mov	al, 40h

gsm_1:					; CODE XREF: get_sharemode+9j
		mov	high$ext, al
		shr	al, 1
		jnz	gsm_2
		mov	al, 80h

gsm_2:					; CODE XREF: get_sharemode+12j
		mov	attributes, al	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_close:		; CODE XREF: F_CLOSE+Ej F_CLOSE+18j
					; ...
		test	fcb_is_for_dir,	0FFh
		jz	fat_closefile
		call	get_cwd_cluster
		jz	not_in_subdir
		xor	bl, bl
		mov	user_fcb+0Ch, bl
		jmp	diropen_dot
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

not_in_subdir:				; CODE XREF: fat_close+Aj
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_closefile:				; CODE XREF: fat_close+5j
		test	byte ptr dpb_cks+1, 80h
		jnz	fcf_fixeddisc
		mov	dir_check_flag,	0F0h

fcf_fixeddisc:				; CODE XREF: fat_close+1Bj
		call	lookup_dirent
		or	ax, ax
		jnz	fcf_gotdirent
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fcf_gotdirent:				; CODE XREF: fat_close+27j
		test	user_fcb+0Eh, 80h
		jnz	fcf_fatclean
		call	write_FAT

fcf_fatclean:				; CODE XREF: fat_close+31j
		call	fs_noop
		test	user_fcb+0Eh, 40h
		jz	fcf_direntclean
		call	fat_wr_dirent
		call	call_xios_flush

fcf_direntclean:			; CODE XREF: fat_close+3Ej
		and	user_fcb+0Eh, 3Fh
		or	user_fcb+0Eh, 80h; Reset 'dirty' flags
		jmp	f_close_end



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_make:		; CODE XREF: F_MAKE+20j
		mov	cl, 80h
		call	get_sharemode
		call	lookup_dirent
		or	ax, ax
		jz	fmake_notfound
		mov	ah, 8
		jmp	disk_error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fmake_notfound:				; CODE XREF: fat_make+Aj
		call	set$end$dir
		mov	cx, 1
		call	fat_search1
		or	ax, ax
		jnz	fat_make5
		call	get_cwd_cluster
		jz	fat_make4

fat_make2:				; CODE XREF: fat_make+2Ej
		cmp	ax, dpb_clusters
		jnb	fat_make3
		push	ax
		call	fat_set_eof	; If FAT entry AX is unused, set it to EOF
		pop	bx
		jmps	fat_make2
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_make3:				; CODE XREF: fat_make+27j
		mov	nearby_cluster,	bx
		mov	ax, bx
		call	alloc_cluster
		mov	newdir_cluster,	ax
		mov	bx, ax
		or	ax, ax
		jz	fat_make4
		mov	ax, nearby_cluster
		call	fat_wcluster	; Set cluster[AX] to BX
		mov	ax, newdir_cluster
		mov	bx, max_cluster
		call	fat_wcluster	; Set cluster[AX] to BX
		call	write_FAT
		mov	ax, newdir_cluster
		call	wr_cluster
		call	set$end$dir
		mov	cx, 1
		call	fat_search1
		or	ax, ax
		jnz	fat_make5

fat_make4:				; CODE XREF: fat_make+21j fat_make+40j
					; ...
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_make5:				; CODE XREF: fat_make+1Cj fat_make+66j
		xor	bx, bx
		mov	si, p_dirent

fat_make6:				; CODE XREF: fat_make+80j
		cmp	bl, 0Bh
		jnb	fat_make7
		mov	al, user_fcb+1[bx]
		and	al, 7Fh
		mov	[bx+si], al
		inc	bl
		jmps	fat_make6
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_make7:				; CODE XREF: fat_make+74j
		xor	ax, ax
		mov	di, p_dirent
		add	di, 0Ch
		mov	cx, 0Ah
		rep stosw
		call	fat_today
		call	fat_set_date
		mov	si, p_dirent
		test	fcb_is_for_dir,	0FFh
		jnz	fat_mkdir
		jmp	fat_mkfile
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_mkdir:				; CODE XREF: fat_make+9Fj
		mov	byte ptr 11[si], 10h;	Is directory
		xor	ax, ax
		call	alloc_cluster
		or	ax, ax
		jz	fat_make4
		mov	newdir_cluster,	ax
		mov	si, p_dirent
		mov	26[si], ax
		mov	bx, max_cluster
		call	fat_wcluster	; Set cluster[AX] to BX
		call	write_FAT
		call	seek$copy
		call	set_cwd_cdr
		mov	ax, newdir_cluster
		call	wr_cluster
		mov	ax, newdir_cluster
		xor	bx, bx
		call	clus_to_sec
		call	setdir1
		mov	si, word ptr fs_buffer+2
		mov	byte ptr [si], '.'
		xor	bx, bx

fat_mkdir1:				; CODE XREF: fat_make+F0j
		cmp	bl, 0Ah
		jnb	fat_mkdir2
		mov	byte ptr 1[bx+si], 20h	; ' '
		inc	bl
		jmps	fat_mkdir1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_mkdir2:				; CODE XREF: fat_make+E8j
		mov	byte ptr 11[si], 10h;	Is directory
		mov	ax, newdir_cluster
		mov	26[si], ax	; Cluster
		mov	p_dirent, si
		call	fat_set_date
		mov	si, word ptr fs_buffer+2
		add	si, 20h
		mov	word ptr [si], '..'
		xor	bx, bx

fat_mkdir3:				; CODE XREF: fat_make+11Bj
		cmp	bl, 9
		jnb	fat_mkdir4
		mov	byte ptr 2[bx+si], 20h	; ' '
		inc	bl
		jmps	fat_mkdir3
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_mkdir4:				; CODE XREF: fat_make+113j
		mov	byte ptr 11[si], 10h
		call	get_cwd_cluster
		mov	26[si], ax
		mov	p_dirent, si
		call	fat_set_date
		call	seek
		xor	cx, cx
		call	wrbuff
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_mkfile:				; CODE XREF: fat_make+A1j
		mov	byte ptr 11[si], 20h ; ' '
		call	fs_noop
		mov	al, attributes	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		call	set_cwd_cdr
		call	seek$copy
		mov	ff2c_extent, 0
		mov	bx, 0FFFFh
		push	bx
		inc	bx
		push	bx
		mov	bx, offset user_fcb
		push	bx
		call	fat_fcb_to_cpm
		add	sp, 6
		or	user_fcb+0Eh, 80h
		mov	al, open_G01
		mov	attributes, al	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		jmp	openx1a



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set_cwd_cdr:		; CODE XREF: fat_make+C8p fat_make+141p
		call	get_cwd_cluster
		jnz	set_cwd_cdr_0
		jmp	setcdr
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

set_cwd_cdr_0:				; CODE XREF: set_cwd_cdr+3j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_delete:		; CODE XREF: F_DELETE+Aj
		call	get$atts
		xor	ax, ax

fat_del1:				; CODE XREF: fat_delete+CAj
		cmp	al, 2
		jb	fat_delpass
		jmp	j_write_FAT
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_delpass:				; CODE XREF: fat_delete+7j
		push	ax
		call	set$end$dir

fat_del_dirloop:			; CODE XREF: fat_delete+59j
					; fat_delete+BEj
		call	fat_dirent_next
		or	ax, ax
		pop	ax
		jnz	fat_del_matched
		jmp	fat_del_nxtfile
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_del_matched:			; CODE XREF: fat_delete+16j
		test	attributes, 80h	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		jz	fat_del_file
		retn			; Can't remove password; there is none
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_del_file:				; CODE XREF: fat_delete+20j
		mov	ah, 0FFh
		or	al, al
		jnz	fat_can_del_1
		push	ax
		mov	bx, p_dirent
		test	byte ptr 11[bx], 3; R/O or SYS?
		jz	fat_can_del
		jmp	rof$error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_can_del:				; CODE XREF: fat_delete+32j
		mov	bx, offset user_fcb
		call	chk$wild_cpm
		pop	ax
		jz	fat_can_del_1
		inc	al

fat_can_del_1:				; CODE XREF: fat_delete+27j
					; fat_delete+3Ej
		cmp	al, 1
		jnz	fat_del_skipf
		push	ax
		mov	bx, p_dirent
		test	byte ptr 11[bx], 10h
		jz	target_is_file
		push	bx
		mov	bx, offset user_fcb
		call	chk$wild_cpm
		pop	bx
		jz	fat_del_dirloop
		test	fcb_is_for_dir,	0FFh
		jz	cant_delete
		mov	ax, 26[bx]	; Cluster
		mov	cx, 2

fat_can_del_2:				; CODE XREF: fat_delete+7Aj
		mov	bx, ax
		push	ax
		call	is_dir_empty
		pop	ax
		jz	cant_delete
		call	fat_set_eof	; If FAT entry AX is unused, set it to EOF
		xor	cx, cx
		cmp	ax, dpb_clusters
		jb	fat_can_del_2
		jmps	fat_del_ckinuse
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cant_delete:				; CODE XREF: fat_delete+60j
					; fat_delete+6Fj ...
		pop	ax
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_del_ckinuse:			; CODE XREF: fat_delete+7Cj
		call	is_obj_in_use
		jnz	cant_delete
		dec	dcnt
		or	dir_check_flag,	0Fh
		mov	dname_cluster, 0
		call	fat_dirent_next
		or	ax, ax
		jz	cant_delete
		jmps	fat_zap_dirent
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

target_is_file:				; CODE XREF: fat_delete+4Fj
		call	fs_nop2

fat_zap_dirent:				; CODE XREF: fat_delete+9Dj
		mov	bx, p_dirent
		mov	byte ptr [bx], 0E5h; Deleted
		mov	ax, 26[bx]
		push	bx
		call	fat_freechain	; Zap cluster chain
		pop	bx
		call	seek$copy
		mov	bx, offset user_fcb
		call	chk$wild_cpm
		pop	ax
		jnz	j_write_FAT

fat_del_skipf:				; CODE XREF: fat_delete+44j
		push	ax
		jmp	fat_del_dirloop
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_del_nxtfile:			; CODE XREF: fat_delete+18j
		or	ah, ah
		jnz	fat_del1_next
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_del1_next:				; CODE XREF: fat_delete+C3j
		inc	al
		jmp	fat_del1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

j_write_FAT:				; CODE XREF: fat_delete+9j
					; fat_delete+BBj
		jmp	write_FAT



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

is_obj_in_use:		; CODE XREF: fat_delete+82p
		cli	
		mov	bx, p_dirent
		mov	dx, 26[bx]
		mov	si, bdos_conowner

ck_obj_in_use:				; CODE XREF: is_obj_in_use+3Dj
		test	si, si
		jz	ioiu_alldone
		push	ds
		mov	ds, si

		mov	di, proc_dirname
		pop	ds

		test	di, di
		jz	ioiu_nextproc	; No current dir structure
		mov	al, curdsk
		mov	cx, 10h

ioiu_chkdrive:				; CODE XREF: is_obj_in_use+33j
		mov	bx, [di]
		test	bx, bx
		jz	ioui_nextdrive
		cmp	al, [bx]
		jnz	ioui_nextdrive
		cmp	dx, 6[bx]
		jz	ioiu_driveinuse

ioui_nextdrive:				; CODE XREF: is_obj_in_use+26j
					; is_obj_in_use+2Aj
		inc	di
		inc	di
		loop	ioiu_chkdrive

ioiu_nextproc:				; CODE XREF: is_obj_in_use+1Aj
		push	ds
		mov	ds, si

		mov	si, proc_nextseg
		pop	ds

		jmps	ck_obj_in_use
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

ioiu_driveinuse:			; CODE XREF: is_obj_in_use+2Fj
		inc	dx

ioiu_alldone:				; CODE XREF: is_obj_in_use+Ej
		sti	
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

is_dir_empty:		; CODE XREF: fat_delete+6Bp
		mov	scan_dirent, cx
		xor	bx, bx
		call	clus_to_sec
		call	setdir1
		mov	dir_record, ax
		shl	ax, 1
		shl	ax, 1
		mov	dir_entries, ax
		mov	bx, dpb_clustersize
		mov	cl, 7
		add	cl, dpb_psh
		shr	bx, cl

idempty_loop:				; CODE XREF: is_dir_empty+64j
		push	bx
		call	seek
		call	rdbuff
		pop	bx
		mov	cx, scan_dirent
		mov	dx, dir_entries
		sub	dx, cx
		mov	si, word ptr fs_buffer+2

idempty_scanrec:			; CODE XREF: is_dir_empty+3Dj
		jcxz	idempty_offset0
		add	si, 20h
		loop	idempty_scanrec

idempty_offset0:			; CODE XREF: is_dir_empty+38j
		mov	scan_dirent, cx

scan_dirents:				; CODE XREF: is_dir_empty+52j
		dec	dx
		jl	dir_next_record
		lodsb
		cmp	al, 0
		jz	dirent_blank
		cmp	al, 0E5h
		jnz	dirent_used

dirent_blank:				; CODE XREF: is_dir_empty+49j
		add	si, 1Fh
		jmps	scan_dirents
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

dirent_used:				; CODE XREF: is_dir_empty+4Dj
		xor	ax, ax
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

dir_next_record:			; CODE XREF: is_dir_empty+44j
		mov	ax, dir_record
		add	bcb_record, ax
		adc	bcb_record_h, 0
		dec	bx
		jnz	idempty_loop
		inc	bx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_rename:		; CODE XREF: bdos:479Aj
		call	copy$user$no
		mov	dl, 1
		call	check$wild0
		mov	ah, 9
		jz	rename_wild
		call	set$end$dir
		mov	cx, 1002h	; Does new name	exist?
		call	fat_search1
		or	ax, ax
		jz	fat_rename2
		mov	ah, 8

rename_wild:				; CODE XREF: fat_rename+Aj
		add	fs_param_low, 10h
		mov	cur_fcb_len, 0
		jmp	disk_error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rename2:				; CODE XREF: fat_rename+17j
		call	lookup_dirent
		or	ax, ax
		jnz	fat_rename3
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rename3:				; CODE XREF: fat_rename+2Dj
		mov	bx, ax
		test	byte ptr 11[bx], 10h
		jz	fat_rename4
		jmp	rof$error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rename4:				; CODE XREF: fat_rename+38j
		call	fs_nop2
		xor	bx, bx
		mov	si, p_dirent

fat_rename5:				; CODE XREF: fat_rename+55j
		cmp	bl, 0Bh
		jnb	fat_rename6
		mov	al, user_fcb+11h[bx]
		and	al, 7Fh
		mov	[bx+si], al
		inc	bl
		jmps	fat_rename5
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rename6:				; CODE XREF: fat_rename+49j
		jmp	seek$copy



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

f_attrib_fat:		; CODE XREF: F_ATTRIB+10j
		call	lookup_dirent
		or	ax, ax
		jnz	f_attrib_fat1
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

f_attrib_fat1:				; CODE XREF: f_attrib_fat+5j
		call	get$atts
		test	al, 40h		; Set size
		jz	dont_set_size	; Not asked to set size
		mov	cl, user_fcb+20h
		and	cl, 7Fh
		or	cl, cl
		jz	dont_set_size	; Passed size is 0
		mov	bx, p_dirent
		mov	ax, 28[bx]
		mov	dx, 30[bx]	; DXAX = file size
		or	ax, ax
		jnz	f_attrib_fat2
		or	dx, dx
		jz	dont_set_size

f_attrib_fat2:				; CODE XREF: f_attrib_fat+28j
		test	al, 7Fh
		jz	f_attrib_fat3
		and	al, 80h
		jmps	f_attrib_fat4
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

f_attrib_fat3:				; CODE XREF: f_attrib_fat+30j
		sub	ax, 80h
		sbb	dx, 0

f_attrib_fat4:				; CODE XREF: f_attrib_fat+34j
		xor	ch, ch
		add	ax, cx
		adc	dx, 0
		mov	28[bx], ax
		mov	30[bx], dx

dont_set_size:				; CODE XREF: f_attrib_fat+Fj
					; f_attrib_fat+1Aj ...
		call	fs_nop2
		xor	bx, bx
		mov	si, p_dirent

set_attr_bits:				; CODE XREF: f_attrib_fat+9Cj
		cmp	bl, 0Bh
		jnb	f_attrib_fat12
		mov	ah, user_fcb+1[bx]
		and	ah, 80h
		cmp	bl, 4
		jnb	f_attrib_fat6
		lea	di, 12[si]
		mov	al, 80h
		mov	cl, bl
		shr	al, cl
		jmps	f_attrib_fat9
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

f_attrib_fat6:				; CODE XREF: f_attrib_fat+61j
		cmp	bl, 8
		jb	f_attrib_fat11
		lea	di, 11[si]
		cmp	bl, 8
		jnz	f_attrib_fat7
		mov	al, 1
		jmps	f_attrib_fat9
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

f_attrib_fat7:				; CODE XREF: f_attrib_fat+79j
		cmp	bl, 9
		jnz	f_attrib_fat8
		mov	al, 4
		jmps	f_attrib_fat9
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

f_attrib_fat8:				; CODE XREF: f_attrib_fat+82j
		mov	al, 20h
		xor	ah, 80h

f_attrib_fat9:				; CODE XREF: f_attrib_fat+6Cj
					; f_attrib_fat+7Dj ...
		test	ah, 80h
		jz	f_attrib_fat10
		or	[di], al
		jmps	f_attrib_fat11
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

f_attrib_fat10:				; CODE XREF: f_attrib_fat+90j
		not	al
		and	[di], al

f_attrib_fat11:				; CODE XREF: f_attrib_fat+71j
					; f_attrib_fat+94j
		inc	bl
		jmps	set_attr_bits
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

f_attrib_fat12:				; CODE XREF: f_attrib_fat+55j
		jmp	seek$copy



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_truncate:		; CODE XREF: F_TRUNCATE+10j
		call	get$atts
		test	user_fcb+23h, 0FCh
		jz	fat_trunc_1

fat_trunc_fail:				; CODE XREF: fat_truncate+12j
					; fat_truncate+3Bj ...
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_trunc_1:				; CODE XREF: fat_truncate+8j
		call	lookup_dirent
		or	ax, ax
		jz	fat_trunc_fail
		call	fs_nop2
		mov	si, p_dirent
		test	byte ptr 11[si], 11h
		jz	fat_trunc_2
		jmp	rof$error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_trunc_2:				; CODE XREF: fat_truncate+1Fj
		mov	ax, word ptr user_fcb+21h
		mov	dl, user_fcb+23h
		xor	dh, dh
		mov	cl, 7
		call	shl_dxax_cl
		add	ax, 80h
		adc	dx, 0
		cmp	dx, 30[si]
		ja	fat_trunc_fail
		jb	fat_trunc_3
		cmp	ax, 28[si]
		jnb	fat_trunc_fail

fat_trunc_3:				; CODE XREF: fat_truncate+3Dj
		mov	28[si], ax
		mov	30[si], dx
		or	byte ptr 11[si], 20h
		sub	ax, 1
		sbb	dx, 0
		mov	cx, dpb_clustersize
		div	cx
		mov	bx, 26[si]
		or	bx, bx
		jnz	fat_trunc_5

fat_trunc_4:				; CODE XREF: fat_truncate+68j
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_trunc_5:				; CODE XREF: fat_truncate+5Fj
					; fat_truncate+78j
		cmp	bx, dpb_clusters
		jnb	fat_trunc_4
		or	ax, ax
		jz	fat_trunc_6
		dec	ax
		push	ax
		mov	ax, bx
		call	fat_set_eof	; If FAT entry AX is unused, set it to EOF
		mov	bx, ax
		pop	ax
		jmps	fat_trunc_5
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_trunc_6:				; CODE XREF: fat_truncate+6Cj
		mov	ax, bx
		push	bx
		call	fat_set_eof	; If FAT entry AX is unused, set it to EOF
		pop	bx
		cmp	ax, dpb_clusters
		jnb	fat_trunc_7
		push	bx
		call	fat_freechain
		pop	ax
		mov	bx, max_cluster
		call	fat_wcluster	; Set cluster[AX] to BX
		call	write_FAT

fat_trunc_7:				; CODE XREF: fat_truncate+85j
		call	fat_today
		call	fat_set_date
		jmp	seek$copy



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_timedate:		; CODE XREF: F_TIMEDATE+Dj
		call	lookup_dirent
		or	ax, ax
		jnz	fat_timedate1
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_timedate1:				; CODE XREF: fat_timedate+5j
		mov	di, offset user_fcb+0Ch
		mov	cx, 4
		xor	ax, ax
		rep stosw
		call	fat_get_date
		call	dos_date_to_cpm
		mov	si, offset fs_days
		mov	di, offset user_fcb+14h
		movsw
		movsw
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_bdos_74:		; CODE XREF: F_BDOS_74+10j
		call	lookup_dirent
		or	ax, ax
		jnz	fat_setstamp_1
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_setstamp_1:				; CODE XREF: fat_bdos_74+5j
		mov	si, offset passwd_buf+4
		mov	di, offset fs_days
		movsw
		movsw
		xor	al, al
		stosb
		call	timestamp_2_fat
		call	fat_set_date
		jmp	seek$copy



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_size:		; CODE XREF: F_SIZE+7j
		mov	dx, 0FFFFh
		push	ax
		push	dx
		call	set$end$dir

fsize_next:				; CODE XREF: fat_size+2Cj
		call	fat_dirent_next
		or	ax, ax
		jz	fsize_nomatch
		mov	si, ax
		pop	dx
		pop	ax
		cmp	dx, 0FFFFh
;
; Take the size	of the biggest matching	file
;
		jz	fsize_gotsize
		cmp	dx, 30[si]
		jb	fsize_gotsize
		ja	fsize_haventgot
		cmp	ax, 28[si]
		jnb	fsize_haventgot

fsize_gotsize:				; CODE XREF: fat_size+16j fat_size+1Bj
		mov	ax, 28[si]
		mov	dx, 30[si]

fsize_haventgot:			; CODE XREF: fat_size+1Dj fat_size+22j
		push	ax
		push	dx
		jmps	fsize_next
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fsize_nomatch:				; CODE XREF: fat_size+Dj
		pop	dx
		pop	ax
		cmp	dx, 0FFFFh
		jnz	fsize_havesize
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fsize_havesize:				; CODE XREF: fat_size+33j
		mov	di, offset user_fcb+21h



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

size_to_records:		; CODE XREF: fat_space+28p
		test	al, 7Fh
		jz	s2r_noround
		and	al, 80h
		add	ax, 80h
		adc	dx, 0

s2r_noround:				; CODE XREF: size_to_records+2j
		mov	cx, 7
		call	shr_dxax_cl
		mov	es:[di], al
		mov	es:1[di], ah
		mov	es:2[di], dl
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; If FAT entry AX is unused, set it to EOF

fat_set_eof:		; CODE XREF: rd$subdir1+31p
					; fat_make+2Ap	...
		push	ax
		call	fat_get		; Return FAT entry [AX]
		pop	bx
		or	ax, ax
		jnz	fat_set_eof_ret
		mov	ax, max_cluster
		push	ax
		xchg	ax, bx
		call	fat_wcluster	; Set cluster[AX] to BX
		pop	ax

fat_set_eof_ret:			; CODE XREF: fat_set_eof+7j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Return FAT entry [AX]

fat_get:		; CODE XREF: fat_set_eof+1p
					; fat_freechain+Bp ...
		mov	di, ax
		cmp	max_cluster, 0FFFFh
		jz	fat_get1
		shr	di, 1
		add	di, ax
		mov	es, dph_hash

		mov	dx, es:[di]
		test	ax, 1
		jz	fat_get2
		mov	cl, 4
		shr	dx, cl
		jmps	fat_get3
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_get1:				; CODE XREF: fat_get+7j
		shl	di, 1
		mov	es, dph_hash
		mov	dx, es:[di]
		jmps	fat_get3
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_get2:				; CODE XREF: fat_get+17j
		and	dx, 0FFFh

fat_get3:				; CODE XREF: fat_get+1Dj fat_get+28j
		mov	ax, ds
		mov	es, ax

		mov	ax, dx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Set cluster[AX] to BX

fat_wcluster:		; CODE XREF: fat_make+45p fat_make+4Fp
					; ...
		mov	di, ax
		cmp	max_cluster, 0FFFFh
		jz	fat_wcluster16
		shr	di, 1
		add	di, ax
		test	ax, 1
		jz	fat_wcluster12a
		mov	cl, 4
		shl	bx, cl
		mov	ax, 0Fh
		jmps	fat_wcluster12
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_wcluster16:				; CODE XREF: fat_wcluster+7j
		shl	di, 1
		mov	es, dph_hash

		mov	es:[di], bx
		jmps	fat_wcls_end
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_wcluster12a:			; CODE XREF: fat_wcluster+10j
		mov	ax, 0F000h

fat_wcluster12:				; CODE XREF: fat_wcluster+19j
		mov	es, dph_hash
		and	es:[di], ax
		or	es:[di], bx

fat_wcls_end:				; CODE XREF: fat_wcluster+24j
		mov	ax, ds
		mov	es, ax

		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_freechain:		; CODE XREF: fat_delete+ADp
					; fat_truncate+88p ...
		or	ax, ax
		jz	fat_fc_done
		cmp	ax, dpb_clusters
		jnb	fat_fc_done
		push	ax
		call	fat_get		; Return FAT entry [AX]
		pop	bx
		push	ax
		mov	ax, bx
		xor	bx, bx
		call	fat_wcluster	; Set cluster[AX] to BX
		pop	ax
		jmps	fat_freechain
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_fc_done:				; CODE XREF: fat_freechain+2j
					; fat_freechain+8j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_space:		; CODE XREF: DRV_SPACE+Aj
		xor	cx, cx
		mov	ax, 2

fatspace_count:				; CODE XREF: fat_space+18j
		cmp	ax, dpb_clusters
		jnb	fatspace_done
		push	ax
		push	cx
		call	fat_get		; Return FAT entry [AX]
		pop	cx
		or	ax, ax
		jnz	fatspace_used
		inc	cx

fatspace_used:				; CODE XREF: fat_space+13j
		pop	ax
		inc	ax
		jmps	fatspace_count
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fatspace_done:				; CODE XREF: fat_space+9j
		mov	ax, cx
		mul	dpb_clustersize
		mov	es, userdmaseg

		mov	di, userdma
		call	size_to_records
		mov	ax, ds
		mov	es, ax

		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; CL: Bit 0=1 for read,	0 for write
;     Bit 1=1 for rand,	0 for seq

fat_rdwr:		; CODE XREF: F_READ+Cj	F_WRITE+Cj
					; ...
		mov	attributes, 0	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		mov	fat_rdwr_flg1, 0
		mov	fat_rdwr_op, cl
		test	cl, 1
		jnz	fat_rdwr2
		mov	ah, 3
		test	high$ext, 40h
		jz	fat_rdwr1
		jmp	disk_error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr1:				; CODE XREF: fat_rdwr+1Aj
		mov	bx, offset user_fcb
		call	check$rofile
		call	check$write
		or	user_fcb+0Eh, 40h

fat_rdwr2:				; CODE XREF: fat_rdwr+11j
		test	fat_rdwr_op, 2
		jz	fat_rdwr5
		test	user_fcb+23h, 0FCh
		jz	fat_rdwr3
		mov	byte ptr aret, 6
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr3:				; CODE XREF: fat_rdwr+39j
		call	calc_extent_no
		mov	ah, user_fcb+0Eh
		and	ah, 3Fh
		cmp	ah, ch
		jnz	fat_rdwr4
		cmp	cl, user_fcb+0Ch
		jz	fat_rdwr7

fat_rdwr4:				; CODE XREF: fat_rdwr+4Dj
		mov	fat_rdwr_flg1, 0FFh
		jmps	fat_rdwr7
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr5:				; CODE XREF: fat_rdwr+32j
		mov	ch, user_fcb+0Eh
		and	ch, 3Fh
		mov	cl, user_fcb+0Ch
		mov	dl, user_fcb+20h
		cmp	dl, 80h
		jb	fat_rdwr7
		cmp	cl, 1Fh
		jnz	fat_rdwr6
		cmp	ch, 3Fh
		jnz	fat_rdwr6
		mov	byte ptr aret, 1
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr6:				; CODE XREF: fat_rdwr+73j fat_rdwr+78j
		mov	fat_rdwr_flg1, 0FFh
		xor	dl, dl
		inc	cl
		cmp	cl, 20h
		jnz	fat_rdwr7
		xor	cl, cl
		inc	ch

fat_rdwr7:				; CODE XREF: fat_rdwr+53j fat_rdwr+5Aj
					; ...
		mov	c2f_S2,	ch
		mov	c2f_EX,	cl
		mov	c2f_RC,	dl
		xor	ax, ax
		mov	ah, dl
		shr	ax, 1
		xor	bx, bx
		mov	bh, cl
		mov	cl, 2
		shr	bx, cl
		or	ah, bl
		xor	dx, dx
		mov	dl, ch
		mov	cl, 3
		shl	dx, cl
		or	dl, bh
		mov	word ptr fat_file_ptr, ax
		mov	word ptr fat_file_ptr+2, dx
		cmp	fs_function, 16h
		jbe	fat_rdwr8
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr8:				; CODE XREF: fat_rdwr+C4j
		mov	bx, dx
		mov	cx, dpb_clustersize
		call	fat_muldiv
		or	dx, dx
		jnz	fat_rdwr9
		inc	ax
		cmp	ax, dpb_clusters
		jb	fat_rdwr11

fat_rdwr9:				; CODE XREF: fat_rdwr+D2j
		mov	al, 2
		test	fat_rdwr_op, 1
		jz	fat_rdwr10
		dec	al

fat_rdwr10:				; CODE XREF: fat_rdwr+E2j
		mov	byte ptr aret, al
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr11:				; CODE XREF: fat_rdwr+D9j
		dec	ax
		mov	dir_record, ax
		mov	dir_entries, cx
		mov	dx, word ptr user_fcb+16h
		mov	ax, dir_record
		cmp	ax, dx
		jnz	fat_rdwr12
		cmp	word ptr user_fcb+14h, 0
		jz	fat_rdwr12
		jmp	fat_rdwr28
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr12:				; CODE XREF: fat_rdwr+FBj fat_rdwr+102j
		mov	open_unknown, 0FFh
		cmp	ax, dx
		jb	fat_rdwr13
		cmp	word ptr user_fcb+14h, 0
		jz	fat_rdwr13
		sub	ax, dx
		mov	scan_dirent, ax
		mov	ax, word ptr user_fcb+14h
		mov	nearby_cluster,	ax
		mov	word_A15_7B1, ax
		call	fat_set_eof	; If FAT entry AX is unused, set it to EOF
		mov	newdir_cluster,	ax
		jmps	fat_rdwr16
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr13:				; CODE XREF: fat_rdwr+10Ej
					; fat_rdwr+115j
		mov	word ptr user_fcb+14h, 0
		inc	ax
		mov	scan_dirent, ax
		mov	ax, word ptr user_fcb+1Ah
		mov	newdir_cluster,	ax
		or	ax, ax
		jnz	fat_rdwr14
		call	fat_getfsize
		mov	ax, word ptr user_fcb+1Ah
		mov	newdir_cluster,	ax

fat_rdwr14:				; CODE XREF: fat_rdwr+13Fj
		or	ax, ax
		jnz	fat_rdwr15
		mov	attributes, 80h	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'

fat_rdwr15:				; CODE XREF: fat_rdwr+14Cj
		mov	nearby_cluster,	0
		mov	word_A15_7B1, 0

fat_rdwr16:				; CODE XREF: fat_rdwr+12Bj
					; fat_rdwr+209j
		test	scan_dirent, 0FFFFh
		jnz	fat_rdwr17
		jmp	fat_rdwr27
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr17:				; CODE XREF: fat_rdwr+165j
		dec	scan_dirent
		mov	ax, newdir_cluster
		or	ax, ax
		jz	fat_rdwr18
		cmp	ax, dpb_clusters
		jnb	fat_rdwr18
		jmp	fat_rdwr25
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr18:				; CODE XREF: fat_rdwr+173j
					; fat_rdwr+179j
		test	fat_rdwr_op, 1
		jz	fat_rdwr19
		jmp	f_ret_1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr19:				; CODE XREF: fat_rdwr+183j
		mov	ax, nearby_cluster
		call	alloc_cluster
		or	ax, ax
		jz	fat_rdwr22
		mov	newdir_cluster,	ax
		mov	bx, ax
		and	user_fcb+0Eh, 7Fh
		mov	ax, nearby_cluster
		or	ax, ax
		jz	fat_rdwr20
		call	fat_wcluster	; Set cluster[AX] to BX
		jmps	fat_rdwr21
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr20:				; CODE XREF: fat_rdwr+1A1j
		mov	word ptr user_fcb+1Ah, bx

fat_rdwr21:				; CODE XREF: fat_rdwr+1A6j
		mov	ax, newdir_cluster
		mov	bx, max_cluster
		call	fat_wcluster	; Set cluster[AX] to BX
		cmp	fs_function, 16h
		jnz	fat_rdwr26
		mov	ax, newdir_cluster
		call	wr_cluster
		jmp	fat_rdwr26
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr22:				; CODE XREF: fat_rdwr+190j
		mov	ax, word_A15_7B1
		or	ax, ax
		jz	fat_rdwr23
		call	fat_set_eof	; If FAT entry AX is unused, set it to EOF
		cmp	ax, dpb_clusters
		jnb	fat_rdwr24
		call	fat_freechain
		mov	ax, word_A15_7B1
		mov	bx, max_cluster
		call	fat_wcluster	; Set cluster[AX] to BX
		jmps	fat_rdwr24
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr23:				; CODE XREF: fat_rdwr+1CBj
		mov	ax, word ptr user_fcb+1Ah
		call	fat_freechain
		mov	word ptr user_fcb+1Ah, 0

fat_rdwr24:				; CODE XREF: fat_rdwr+1D4j
					; fat_rdwr+1E3j
		mov	byte ptr aret, 2
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr25:				; CODE XREF: fat_rdwr+17Bj
		mov	ax, newdir_cluster
		mov	word_A15_7B1, ax

fat_rdwr26:				; CODE XREF: fat_rdwr+1BBj
					; fat_rdwr+1C3j
		mov	ax, newdir_cluster
		mov	nearby_cluster,	ax
		call	fat_set_eof	; If FAT entry AX is unused, set it to EOF
		mov	newdir_cluster,	ax
		jmp	fat_rdwr16
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr27:				; CODE XREF: fat_rdwr+167j
		mov	ax, nearby_cluster
		mov	word ptr user_fcb+14h, ax
		mov	ax, dir_record
		mov	word ptr user_fcb+16h, ax
		jmps	fat_rdwr29
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr28:				; CODE XREF: fat_rdwr+104j
		mov	ax, word ptr user_fcb+14h
		mov	nearby_cluster,	ax

fat_rdwr29:				; CODE XREF: fat_rdwr+218j
					; fat_rdwr+241j
		xor	ch, ch
		mov	ax, word ptr fat_file_ptr+2
		cmp	ax, word ptr user_fcb+1Eh
		ja	fat_rdwr30
		jb	fat_rdwr31
		mov	ax, word ptr fat_file_ptr
		cmp	ax, word ptr user_fcb+1Ch
		jb	fat_rdwr31

fat_rdwr30:				; CODE XREF: fat_rdwr+229j
		mov	ch, 0FFh

fat_rdwr31:				; CODE XREF: fat_rdwr+22Bj
					; fat_rdwr+234j
		or	ch, ch
		jz	fat_rdwr32
		call	fat_getfsize
		or	ax, ax
		jnz	fat_rdwr29
		mov	ch, 0FFh

fat_rdwr32:				; CODE XREF: fat_rdwr+23Aj
		test	fat_rdwr_op, 1
		jnz	fat_rdwr35
		cmp	fs_function, 16h
		jz	fat_rdwr34
		or	ch, ch
		jz	fat_rdwr34
		mov	al, dpb_phm
		xor	ah, ah
		mov	cl, 7
		shl	ax, cl
		test	word ptr fat_file_ptr, ax
		jz	fat_rdwr33
		mov	ax, word ptr fat_file_ptr
		mov	dx, word ptr fat_file_ptr+2
		mov	cl, dpb_psh
		add	cl, 7
		push	cx
		call	shr_dxax_cl
		pop	cx
		push	ax
		push	dx
		mov	ax, word ptr user_fcb+1Ch
		mov	dx, word ptr user_fcb+1Eh
		call	shr_dxax_cl
		pop	cx
		pop	bx
		sub	bx, ax
		sbb	cx, dx
		or	bx, cx
		jz	fat_rdwr34

fat_rdwr33:				; CODE XREF: fat_rdwr+264j
		mov	fat_deblock?, 0
		jmps	fat_rdwr36
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr34:				; CODE XREF: fat_rdwr+251j
					; fat_rdwr+255j ...
		mov	fat_deblock?, 0FFh
		jmps	fat_rdwr36
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr35:				; CODE XREF: fat_rdwr+24Aj
		or	ch, ch
		jz	fat_rdwr36
		jmp	f_ret_1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr36:				; CODE XREF: fat_rdwr+294j
					; fat_rdwr+29Bj ...
		mov	ax, nearby_cluster
		mov	bx, dir_entries
		call	clus_to_sec
		call	fat_rdwr_sub1
		cmp	ax, 0FFFFh
		jz	fat_rdwr37
		call	fat_rdwr_ckd
		jmps	fat_rdwr39
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr37:				; CODE XREF: fat_rdwr+2B4j
		test	fat_rdwr_op, 1
		jnz	fat_rdwr39
		test	dpb_phm, 0FFh
		jz	fat_rdwr38
		mov	al, byte ptr bcb_record
		test	dpb_phm, al
		jnz	fat_rdwr39

fat_rdwr38:				; CODE XREF: fat_rdwr+2C7j
		call	discard$databcb	; Release the BCB for bcb_drive, record	bcb_record

fat_rdwr39:				; CODE XREF: fat_rdwr+2B9j
					; fat_rdwr+2C0j ...
		add	word ptr fat_file_ptr, 80h
		adc	word ptr fat_file_ptr+2, 0

fat_rdwr40:				; CODE XREF: fat_rdwr+2F9j
		mov	ax, word ptr fat_file_ptr+2
		cmp	ax, word ptr user_fcb+1Eh
		ja	fat_rdwr41
		jb	fat_rdwr43
		mov	ax, word ptr fat_file_ptr
		cmp	ax, word ptr user_fcb+1Ch
		jbe	fat_rdwr43

fat_rdwr41:				; CODE XREF: fat_rdwr+2E7j
		call	fat_getfsize
		or	ax, ax
		jnz	fat_rdwr40
		test	fat_rdwr_op, 1
		jz	fat_rdwr42
		mov	ax, word ptr fat_file_ptr+2
		sub	ax, word ptr user_fcb+1Eh
		mov	ax, word ptr fat_file_ptr
		sbb	ax, word ptr user_fcb+1Ch
		mov	bx, 80h
		sub	bx, ax
		mov	di, userdma
		add	di, bx
		mov	es, userdmaseg

		mov	cx, ax
		xor	al, al
		rep stosb
		mov	ax, ds
		mov	es, ax

		jmps	fat_rdwr43
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr42:				; CODE XREF: fat_rdwr+300j
		mov	ax, word ptr fat_file_ptr
		mov	word ptr user_fcb+1Ch, ax
		mov	fat_rdwr_flg1, 0FFh
		mov	ax, word ptr fat_file_ptr+2
		mov	word ptr user_fcb+1Eh, ax
		mov	open_unknown, 0FFh
		call	fat_rw_u

fat_rdwr43:				; CODE XREF: fat_rdwr+2E9j
					; fat_rdwr+2F2j ...
		mov	al, user_fcb+0Eh
		and	al, 0C0h
		or	al, c2f_S2
		mov	user_fcb+0Eh, al
		mov	al, c2f_EX
		mov	user_fcb+0Ch, al
		mov	al, c2f_RC
		mov	user_fcb+20h, al
		test	fat_rdwr_flg1, 0FFh
		jz	fat_rdwr46
		call	c2f_to_extent
		cmp	ax, 0FFFFh
		jnz	fat_rdwr44
		xor	al, al
		jmps	fat_rdwr45
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr44:				; CODE XREF: fat_rdwr+369j
		mov	cl, 7
		shr	ax, cl

fat_rdwr45:				; CODE XREF: fat_rdwr+36Dj
		mov	user_fcb+0Fh, al

fat_rdwr46:				; CODE XREF: fat_rdwr+361j
		test	fat_rdwr_op, 2
		jnz	fat_rdwr47
		inc	user_fcb+20h

fat_rdwr47:				; CODE XREF: fat_rdwr+37Bj
		test	attributes, 80h	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		jz	fat_rdwr48
		call	fat_close
		cmp	byte ptr aret, 0FFh
		jnz	fat_rdwr48
		mov	ah, 0Ah
		jmp	disk_error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr48:				; CODE XREF: fat_rdwr+386j
					; fat_rdwr+390j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_rdwr_sub1:		; CODE XREF: fat_rdwr+2AEp
		cmp	dir$cnt, 1
		jbe	fat_rdwr_sub2
		dec	dir$cnt
		mov	ax, 0FFFFh
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr_sub2:				; CODE XREF: fat_rdwr_sub1+5j
		mov	al, dpb_phm
		and	al, byte ptr bcb_record
		jnz	fat_rdwr_sub3
		cmp	last_sec_count,	2
		jb	fat_rdwr_sub3
		test	high$ext, 80h
		jnz	fat_rdwr_sub3
		cmp	fs_function, 16h
		jnz	fat_rdwr_sub5

fat_rdwr_sub3:				; CODE XREF: fat_rdwr_sub1+16j
					; fat_rdwr_sub1+1Dj ...
		xor	ax, ax
		test	dpb_phm, 0FFh
		jnz	fat_rdwr_sub4
		mov	al, 1

fat_rdwr_sub4:				; CODE XREF: fat_rdwr_sub1+34j
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr_sub5:				; CODE XREF: fat_rdwr_sub1+2Bj
		mov	ax, nearby_cluster
		xor	cx, cx

fat_rdwr_sub6:				; CODE XREF: fat_rdwr_sub1+4Bj
		push	ax
		push	cx
		call	fat_set_eof	; If FAT entry AX is unused, set it to EOF
		pop	cx
		pop	bx
		inc	bx
		cmp	ax, bx
		jnz	fat_rdwr_sub7
		inc	cx
		jmps	fat_rdwr_sub6
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr_sub7:				; CODE XREF: fat_rdwr_sub1+48j
		test	fat_rdwr_op, 1
		jnz	fat_rdwr_sub9
		cmp	ax, 0FF7h
		jbe	fat_rdwr_sub9

fat_rdwr_sub8:				; CODE XREF: fat_rdwr_sub1+6Ej
		push	bx
		push	cx
		mov	ax, bx
		call	fat_get		; Return FAT entry [AX]
		pop	cx
		pop	bx
		or	ax, ax
		jnz	fat_rdwr_sub9
		cmp	bx, dpb_clusters
		jnb	fat_rdwr_sub9
		inc	bx
		inc	cx
		jmps	fat_rdwr_sub8
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr_sub9:				; CODE XREF: fat_rdwr_sub1+52j
					; fat_rdwr_sub1+57j ...
		mov	ax, dpb_clustersize
		mul	cx
		mov	bx, dpb_clustersize
		sub	bx, dir_entries
		add	ax, bx
		adc	dx, 0
		or	dx, dx
		jnz	fat_rdwr_sub10
		cmp	ax, 4000h
		jb	fat_rdwr_sub11

fat_rdwr_sub10:				; CODE XREF: fat_rdwr_sub1+84j
		mov	ax, 4000h
		xor	dx, dx

fat_rdwr_sub11:				; CODE XREF: fat_rdwr_sub1+89j
		test	fat_rdwr_op, 1
		jz	fat_rdwr_sub14
		mov	bx, word ptr user_fcb+1Ch
		sub	bx, word ptr fat_file_ptr
		mov	cx, word ptr user_fcb+1Eh
		sbb	cx, word ptr fat_file_ptr+2
		jnb	fat_rdwr_sub12
		xor	bx, bx
		xor	cx, cx

fat_rdwr_sub12:				; CODE XREF: fat_rdwr_sub1+A7j
		cmp	cx, dx
		ja	fat_rdwr_sub14
		jb	fat_rdwr_sub13
		cmp	bx, ax
		jnb	fat_rdwr_sub14

fat_rdwr_sub13:				; CODE XREF: fat_rdwr_sub1+B1j
		mov	ax, bx
		mov	dx, cx

fat_rdwr_sub14:				; CODE XREF: fat_rdwr_sub1+95j
					; fat_rdwr_sub1+AFj ...
		mov	cl, 7
		call	shr_dxax_cl
		cmp	al, last_sec_count
		jbe	fat_rdwr_sub15
		mov	al, last_sec_count

fat_rdwr_sub15:				; CODE XREF: fat_rdwr_sub1+C4j
		mov	bl, al
		mov	cl, dpb_psh
		shr	al, cl
		mov	dl, dpb_phm
		not	dl
		and	bl, dl
		mov	dir$cnt, bl
		push	ax
		or	al, al
		jz	fat_rdwr_sub16
		test	fat_rdwr_op, 1
		jz	fat_rdwr_sub16
		call	flushx

fat_rdwr_sub16:				; CODE XREF: fat_rdwr_sub1+E0j
					; fat_rdwr_sub1+E7j
		pop	ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

alloc_cluster:		; CODE XREF: fat_make+36p fat_make+AAp
					; ...
		or	ax, ax
		jnz	alloc_clus_1
		mov	ax, 1

alloc_clus_1:				; CODE XREF: alloc_cluster+2j
		mov	bx, ax
		inc	bx
		dec	ax

alloc_clus_2:				; CODE XREF: alloc_cluster+37j
					; alloc_cluster+3Dj
		cmp	bx, dpb_clusters
		jnb	alloc_clus_4
		push	ax
		push	bx
		mov	ax, bx
		call	fat_get		; Return FAT entry [AX]
		pop	bx
		or	ax, ax
		pop	ax
		jnz	alloc_clus_3
		mov	ax, bx
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

alloc_clus_3:				; CODE XREF: alloc_cluster+1Cj
		inc	bx

alloc_clus_4:				; CODE XREF: alloc_cluster+Fj
		cmp	ax, 2
		jbe	alloc_clus_6
		push	ax
		push	bx
		call	fat_get		; Return FAT entry [AX]
		pop	bx
		or	ax, ax
		pop	ax
		jnz	alloc_clus_5
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

alloc_clus_5:				; CODE XREF: alloc_cluster+30j
		dec	ax

alloc_clus_6:				; CODE XREF: alloc_cluster+25j
		cmp	ax, 2
		ja	alloc_clus_2
		cmp	bx, dpb_clusters
		jb	alloc_clus_2
		xor	ax, ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_rdwr_ckd:		; CODE XREF: fat_rdwr+2B6p
		mov	cl, fat_rdwr_op
		and	cl, 1
		or	ax, ax
		jz	fat_rdwr_ckd2
		or	cl, cl
		jnz	fat_rdwr_ckd1
		push	ax
		call	discard$databcb	; Release the BCB for bcb_drive, record	bcb_record
		pop	ax
		xor	cl, cl

fat_rdwr_ckd1:				; CODE XREF: fat_rdwr_ckd+Dj
		jmp	recordok1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rdwr_ckd2:				; CODE XREF: fat_rdwr_ckd+9j
		mov	ch, fat_deblock?
		jmp	ddta_1



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

clus_to_sec:		; CODE XREF: rd$subdir1+69p
					; fat_make+D6p	...
		dec	ax
		dec	ax
		mul	dpb_clustersize
		add	ax, bx
		adc	dx, 0
		mov	cl, 7
		call	shr_dxax_cl
		mov	bx, dpb_drm
		add	bx, 4
		mov	cl, 2
		shr	bx, cl
		test	dpb_phm, bl
		jz	clus_to_sec1
		mov	cl, dpb_phm
		xor	ch, ch
		not	cx
		and	bx, cx
		not	cx
		add	bx, cx
		inc	bx

clus_to_sec1:				; CODE XREF: clus_to_sec+1Fj
		add	ax, bx
		adc	dx, 0
		mov	byte ptr bcb_record, al
		mov	byte ptr bcb_record+1, ah
		mov	bcb_record_h, dl
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

wr_cluster:		; CODE XREF: fat_make+58p fat_make+CEp
					; ...
		xor	bx, bx
		call	clus_to_sec
		call	setdir1
		mov	bx, dpb_clustersize
		mov	cl, 7
		add	cl, dpb_psh
		shr	bx, cl
		mov	fat_deblock?, 0

wr_cluster_loop:			; CODE XREF: wr_cluster+32j
		push	ax
		push	bx
		call	discard$databcb	; Release the BCB for bcb_drive, record	bcb_record
		call	seek
		xor	cl, cl
		call	wrbuff
		pop	bx
		pop	ax
		add	bcb_record, ax
		adc	bcb_record_h, 0
		dec	bx
		jnz	wr_cluster_loop
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_getfsize:		; CODE XREF: fat_rdwr+141p
					; fat_rdwr+23Cp ...
		or	dir_check_flag,	0Fh
		test	high$ext, 80h
		jz	fat_getfsize4
		cmp	fs_sectorcount,	1
		jbe	fat_getfsize1
		mov	al, last_sec_count
		cmp	al, fs_sectorcount
		jnz	fat_getfsize4

fat_getfsize1:				; CODE XREF: fat_getfsize+11j
		mov	al, user_fcb+12h
		mov	ah, user_fcb+10h
		and	ah, 1Fh
		dec	ax
		mov	dcnt, ax
		call	fat_dirent_next
		or	ax, ax
		jnz	fat_getfsize2
		pop	bx
		mov	byte ptr aret, 0Bh
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_getfsize2:				; CODE XREF: fat_getfsize+2Fj
		mov	open_unknown, 0FFh
		mov	bx, ax
		mov	ax, 26[bx]
		mov	word ptr user_fcb+1Ah, ax
		mov	dx, 30[bx]
		cmp	word ptr user_fcb+1Eh, dx
		ja	fat_getfsize4
		jb	fat_getfsize3
		mov	ax, 28[bx]
		cmp	word ptr user_fcb+1Ch, ax
		jnb	fat_getfsize4

fat_getfsize3:				; CODE XREF: fat_getfsize+4Ej
		mov	word ptr user_fcb+1Ch, ax
		mov	word ptr user_fcb+1Eh, dx
		mov	fat_rdwr_flg1, 0FFh
		mov	al, 1
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_getfsize4:				; CODE XREF: fat_getfsize+Aj
					; fat_getfsize+1Aj ...
		xor	ax, ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_rw_u:		; CODE XREF: fat_rdwr+341p
		cmp	fs_sectorcount,	1
		ja	fat_rw_u3
		test	high$ext, 80h
		jz	fat_rw_u3
		mov	dir_check_flag,	0Fh
		test	dpb_cks+1, 50h
		jnz	fat_rw_u1
		mov	dir_check_flag,	0FFh

fat_rw_u1:				; CODE XREF: fat_rw_u+19j
		call	lookup_dirent
		or	ax, ax
		jz	fat_rw_u2
		jmps	fat_wr_dirent
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fat_rw_u2:				; CODE XREF: fat_rw_u+25j
		mov	byte ptr aret, 0Bh
		add	sp, 2

fat_rw_u3:				; CODE XREF: fat_rw_u+5j fat_rw_u+Cj
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fat_wr_dirent:		; CODE XREF: fat_close+40p
					; fat_rw_u+27j
		mov	bx, p_dirent
		test	word ptr 26[bx], 0FFFFh
		jnz	fat_wr_dirent1
		mov	ax, word ptr user_fcb+1Ah
		mov	26[bx], ax

fat_wr_dirent1:				; CODE XREF: fat_wr_dirent+9j
		mov	ax, word ptr user_fcb+1Ch
		mov	dx, word ptr user_fcb+1Eh
		cmp	dx, 30[bx]
		ja	fat_wr_dirent2
		jb	fat_wr_dirent3
		cmp	ax, 28[bx]
		jbe	fat_wr_dirent3

fat_wr_dirent2:				; CODE XREF: fat_wr_dirent+1Bj
		mov	28[bx], ax
		mov	30[bx], dx

fat_wr_dirent3:				; CODE XREF: fat_wr_dirent+1Dj
					; fat_wr_dirent+22j
		or	byte ptr 11[bx], 20h;	Archive	bit
		and	user_fcb+0Bh, 7Fh
		jmp	seek$copy



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fs_nop2:		; CODE XREF: fat_delete+9Fp
					; fat_rename+3Dp ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get_cwd_cluster:		; CODE XREF: fat_search1+28p
					; fat_open+Cp ...
		mov	ax, cur_drvdir
		test	ax, ax
		jz	cwd_hasnt_clust
		xchg	ax, bx
		mov	ax, 6[bx]	; Cluster
		or	ax, ax

cwd_hasnt_clust:			; CODE XREF: get_cwd_cluster+5j
		retn	


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

	if	DONTWRITE_PATCH

patch_dontwrite:			; CODE XREF: cpm_writerec+114j
		mov	cl, blk$off
		call	lru_ckdirty	; Returns Carry	set if buffer dirty?
		call	discard$databcb	; Release the BCB for bcb_drive, record	bcb_record
		jmp	dont$write1

	else

		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop

	endif

;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ
;
; Patch	to "Read-only disk" error
;

		if	ROD_ERROR_PATCH
rod_err_patch:				; CODE XREF: bdos:2920j
		mov	bx, dph_dtabcb
		test	bx, bx
		jz	true_rod_err
		mov	bx, [bx]

bcb_discard:				; CODE XREF: bdos:6193j
		mov	al, bcb_drive
		cmp	al, [bx]
		jnz	bcb_discard_nxt	; Not for this drive
		mov	ax, rlr
		cmp	ax, 14[bx]
		jnz	bcb_discard_nxt	; Not for this process
		sub	ax, ax		; Dump BCB contents hard on the	floor
		mov	14[bx], ax
		mov	4[bx],	al
		dec	ax
		mov	[bx], al

bcb_discard_nxt:			; CODE XREF: bdos:6179j bdos:6181j
		mov	bx, 12[bx]
		test	bx, bx
		jnz	bcb_discard

true_rod_err:				; CODE XREF: bdos:6170j
		mov	ah, 2
		jmp	goerr
	
	else				;ROD_ERROR_PATCH

		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	

	endif

;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ
		nop			; Code segment patch space
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	

		dseg
		public	dirname_0
		public	dirname_1
		public	dirdata_0
		public	readonly_vector
		public	login_vector

removable_drive	dw 0			; DATA XREF: check_changed+5r
					; media$change+Fo ...
		dw 0,0
readonly_vector	dw 0			; DATA XREF: DRV_ROVECr nowriter
					; ...
login_vector	dw 0			; DATA XREF: DRV_LOGINVECr
					; rdbuff+28r ...
		db 0
fcbdsk		db 0			; DATA XREF: funcs_F_main+6Eo
					; F_do_call+51r ...
cur_fcb_len	db 0			; DATA XREF: funcs_F_main+ADr
					; copy_fcb_36+2w ...
aret		dw 0			; DATA XREF: funcs_F_main+F3r
					; F_repeat_call+1Ar ...
set_if_attrs	db 0			; DATA XREF: funcs_F_main+113r
					; F_do_call+2Br ...
dir_check_flag	db 0			; DATA XREF: deblock+B2w rd$subdir1+50r
					; ...
open_unknown	db 0			; DATA XREF: open$reel+74w
					; openx+90w ...
search$user0	db 0			; DATA XREF: bdos:371Cw bdos:374Er
					; ...
make$xfcb	db 0			; DATA XREF: make+22r F_MAKE+9Ew
					; ...
find$xfcb	db 0			; DATA XREF: search$h_sub+46r
					; searchn+4Ar ...
xdcnt		dw 0			; DATA XREF: set_dcnt_dblkr
					; search$h_sub+58w ...
dir$cnt		db 0			; DATA XREF: check$nprs+4r
					; check$nprs+Dw ...
last_sec_count	db 0			; DATA XREF: F_repeat_call+Bw
					; check$nprs+29r ...
readf$sw	db 0			; DATA XREF: rdbuff+Bw	rdbuff+4Fr
err_major	db 0			; DATA XREF: funcs_F_main+104r
					; errorw
relog		db 0			; DATA XREF: tst$relog+2w rdbuff+44w
					; ...
fcb_is_for_dir	db 0			; DATA XREF: funcs_F_main+C2r
					; F_do_call+17w ...
		dw 0
fs_rdwrcount	db 1			; DATA XREF: xios_rdwr+Ew bdos:2C56w
					; ...
blk$off		db 0			; DATA XREF: atran+1Dw	deblock+11Ar
					; ...
arecord1	dw 0			; DATA XREF: atran+7w lru_ckdirty+14r
p_lru_first	dw offset lru_1		; DATA XREF: lru_toucho lru_touch+1Ew
					; ...
lru_1		dw offset lru_2		; DATA XREF: dseg:05E7o
		dw 0
		dw 0FFh
lru_2		dw offset lru_3		; DATA XREF: dseg:05E9o
		dw 0
		dw 0FFh
lru_3		dw offset lru_4		; DATA XREF: dseg:05EFo
		dw 0
		dw 0FFh
lru_4		dw offset lru_5		; DATA XREF: dseg:05F5o
		dw 0
		dw 0FFh
lru_5		dw offset lru_6		; DATA XREF: dseg:05FBo
		dw 0
		dw 0FFh
lru_6		dw 0			; DATA XREF: dseg:0601o
		dw 0
		dw 0FFh
hash		rb 4			; DATA XREF: get$hash+3w get$hash+Cw
					; ...
hashl		db 0			; DATA XREF: media$change+Cw
					; set$hash+16w	...
deblock_command	db 0			; DATA XREF: deblock+76w deblock+A9r
					; ...
phy$off		db 0			; DATA XREF: get$bcba+6Cr get$bcba+EEr
					; ...
curbcba		dw 0			; DATA XREF: get$bcba+53w get$bcba+5Fr
					; ...
rootbcba	dw 0			; DATA XREF: get$bcbaw	get$bcba+DBr
					; ...
emptybcba	dw 0			; DATA XREF: get$bcba+16w get$bcba+2Br
					; ...
seqbcba		dw 0			; DATA XREF: get$bcba+19w get$bcba+4Fw
					; ...
my_bcbs		db 0			; DATA XREF: get$bcba+1Cw get$bcba+4Bw
					; ...
					; BCBs owned by	this process
fs_function	db 0			; DATA XREF: bdos:25EBr funcs_F_main+14w
					; ...
fs_track	dw 0			; DATA XREF: xios_rdwr+13r
					; seek+40w ...
fs_sector	dw 0			; DATA XREF: xios_rdwr+17r
					; seek+43w ...
fs_param_low	dw 0			; DATA XREF: bdos:25FFr funcs_F_main+73w
					; ...
searcha		dw 0			; DATA XREF: searchi+3w searchn+14r
					; ...
fs_fcbdrive	db 0			; DATA XREF: funcs_F_main+30w
					; error+4r ...
usrcode		db 0			; DATA XREF: reselect+40r F_OPEN+2Cr
					; ...
fs_param_ds	dw 0			; DATA XREF: funcs_F_main+37w
					; funcs_F_main+BCr ...
f_ret_es	dw 0			; DATA XREF: funcs_F_main+3Ew
					; funcs_F_main+ECr ...
userdma		dw 0			; DATA XREF: funcs_F_main+4Eo
					; funcs_F_main+58r ...
userdmaseg	dw 0			; DATA XREF: funcs_F_main+5Fw
					; deblock+171r	...
sys_fx		db 0			; DATA XREF: funcs_F_main+E1o
searchl		db 0			; DATA XREF: search$hash+7r
					; searchi+Cw ...
sys_find1st	dw 0,0			; DATA XREF: F_SFIRST+9w bdos:461Cr
					; ...
dcnt		dw 0			; DATA XREF: end$of$diro set$end$dirw
					; ...
ff2c_extent	dw 0			; DATA XREF: srch_fat+7w srch_fat+22w
					; ...
fs_errormode	db 0			; DATA XREF: sel$error+Cr disk_error+Cr
					; ...
fs_sectorcount	db 0			; DATA XREF: funcs_F_main+97r
					; F_repeat_call+8r ...
df$password	rb 8			; DATA XREF: cmp$pw+36o F_PASSWD+Fo
					; Default password
high$ext	db 0			; DATA XREF: F_do_call+3Br
					; chek$fcbr ...
xfcb_rdonly	db 0			; DATA XREF: F_do_call+32r
					; cpm_writerec+Fr ...
curdsk		db 0FFh			; DATA XREF: xios_rdwr+8r sel$errorw
					; ...
cdrmaxa		dw 0			; DATA XREF: compcdr+4r cpm_login+3Br
					; ...
lsn$add		dw 0			; DATA XREF: chek$fcb+Cr set$lsnr
					; ...
buffa		dw 0			; DATA XREF: compute$csr getdptra+6r
					; ...
dph_dpb		dw 0			; DATA XREF: drive_login+1Eo
					; drive_login+26r ...
dph_csv		dw 0			; DATA XREF: r$dir+50r
dph_alv		dw 0			; DATA XREF: getallocbit+Dr
					; copy$alv+Br ...
dph_dirbcb	dw 0			; DATA XREF: discard$dirr deblock+4r
					; ...
dph_dtabcb	dw 0			; DATA XREF: discard$databcbr
					; deblock+13r ...
dph_hash	dw 0			; DATA XREF: set$hashr	search$hashr
					; ...
dpb_fatcount	dw 0			; DATA XREF: seek+26r drive_login+43o
					; ...
dpb_secperfat	dw 0			; DATA XREF: seek+29r load_fats+16r
					; ...
dpb_clusters	dw 0			; DATA XREF: rd$subdir1+35r
					; fat_make+23r	...
dpb_clustersize	dw 0			; DATA XREF: rd$subdir1+15r
					; drive_login+59r ...
dpb_firstfat	dw 0			; DATA XREF: seek+1Er load_fatsr
					; ...
dpb_spt		dw 0			; DATA XREF: seek+32r seek+38r
					; ...
dpb_bsh		db 0			; DATA XREF: atranr dm$positionr
					; ...
dpb_blm		db 0			; DATA XREF: atran+19r	check$nprs+53r
					; ...
dpb_exm		db 0			; DATA XREF: get$dir$ext+2Br
					; compext+1r ...
dpb_dsm		dw 0			; DATA XREF: get$nalbsr scandm$a+37r
					; ...
dpb_drm		dw 0			; DATA XREF: r$dirr search$hash+1Fr
					; ...
dpb_al0_al1	dw 0			; DATA XREF: scandm$a+16r cpm_login+25r
dpb_cks		dw 0			; DATA XREF: rdbuff+20r r$dir+3Dr
					; ...
dpb_off		dw 0			; DATA XREF: seek+3Cr
dpb_psh		db 0			; DATA XREF: seek+9r check$nprs+104r
					; ...
dpb_phm		db 0			; DATA XREF: get$bcba+92r lru_ckdirty+29r
					; ...
fat_buf_dirty?	db 0			; DATA XREF: lru_ckdirty+7r
					; bdos:2EFAw
		db 0
F_isfatfs	db 0			; DATA XREF: seek+17r lru_ckdirtyr
					; ...
passwd_buf	rb 10h
					; cmp$pw+21o ...
open_G01	db 0			; DATA XREF: cpm_opendir+18Bw
					; fat_make+162r
result_F0F	db 0			; DATA XREF: F_do_call+4Br
					; make+60w
save$xfcb	db 0			; DATA XREF: searchn+37w searchn+51w
					; ...
openreel_S2	db 0			; DATA XREF: open$reel+3w open$reel+66r
pw$mode		db 0			; DATA XREF: chk$pw$error+24w
					; chk$pw$error+33o ...
					; Password mode
attributes	db 0			; DATA XREF: get$atts+17w cpm_delete+16r
					; ...
					; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		rb 4
rmf		db 0			; DATA XREF: open$reel+44r
					; open$reel+90r ...
					; Read mode flag
deblock_flag	db 0			; DATA XREF: cpm_writerec+92w
					; cpm_writerec+A0r ...
dirloc		db 0			; DATA XREF: bdos:3431r searchi+7w
					; ...
linfo		db 0			; DATA XREF: funcs_F_main+77w
					; DRV_SET+3r ...
dminx		db 0			; DATA XREF: index+3w get$dir$ext+14w
					; ...
single		db 0			; DATA XREF: get$dm+5r	get$dir$ext+18r
					; ...
					; Nonzero if using 8-bit blocks
rcount		db 0			; DATA XREF: getfcb+1Ew setfcb+19r
					; ...
extval		db 0			; DATA XREF: dm$position+Fr
					; getfcb+28w
vrecord		db 0			; DATA XREF: atran+16r	dm$position+4r
					; ...
bcb_drive	db 0			; DATA XREF: rdbuff+17r rdbuff+3Br
					; ...
bcb_record	dw 0			; DATA XREF: xios_rdwrr seekr	...
bcb_record_h	db 0			; DATA XREF: xios_rdwr+4r seek+5r
					; ...
bcb_dirty	dw 0			; DATA XREF: atran+12w	cpm_login+38w
					; ...
drec		dw 0			; DATA XREF: rd$dir+7w	r$dir+39r
					; ...
fs_buffer	dw 0,0			; DATA XREF: xios_rdwr+1Br
					; deblockw ...
dptr		db 0			; DATA XREF: getdptrar	drv$relog+8w
					; ...
user0$pass	db 0			; DATA XREF: searchnw bdos:3708r
					; ...
call_flags	dw 0			; DATA XREF: F_repeat_callw
					; F_repeat_call+Fr
fcb_randrec_num	rb 3
error_drive	db 0			; DATA XREF: funcs_F_main+11Fr
					; error+7w
strColonSpace	db ' : $'               ; DATA XREF: funcs_F_main+14Bw
					; funcs_F_main+14Fo
error_strings	dw 0			; DATA XREF: funcs_F_main+15Do
		dw offset addr_writeerr
		dw offset addr_rodisk
		dw offset addr_rofile
		dw offset addr_invaliddrv
		dw 0
		dw 0
		dw offset addr_pwderr
		dw offset addr_filexists
		dw offset addr_ambiguous
		rw 3
errFilename	rb 0Ch
		db '$'
		rb 8Ah
F_entry_sp	dw 0			; DATA XREF: funcs_F_main+27o
					; F_do_callw ...
F_old_ss	dw 0			; DATA XREF: funcs_F_main+1Bw
					; funcs_F_main+FAr
F_old_sp	dw 0			; DATA XREF: funcs_F_main+1Fw
					; funcs_F_main+FEr
user_fcb	rb 24h
		rb 4
passwd_fcb	rb 10h
					; restore$pw$fcbo
fat_rdwr_op	db 0			; DATA XREF: fat_rdwr+Aw fat_rdwr+2Dr
					; ...
newdir_cluster	dw 0			; DATA XREF: fat_make+39w fat_make+48r
					; ...
scan_dirent	dw 0			; DATA XREF: is_dir_emptyw
					; is_dir_empty+2Ar ...
dir_record	dw 0			; DATA XREF: is_dir_empty+Cw
					; is_dir_empty+57r ...
dir_entries	dw 0			; DATA XREF: is_dir_empty+13w
					; is_dir_empty+2Er ...
fs_days		dw 0			; DATA XREF: fat_to_sfcb+21o
					; dos_date_to_cpm+39w
					; ...
fs_hours	db 0			; DATA XREF: dos_date_to_cpm+42w
					; timestamp_2_fat+5Ar
fs_minutes	db 0			; DATA XREF: dos_date_to_cpm+4Bw
					; timestamp_2_fat+63r
fs_seconds	db 0			; DATA XREF: timestamp_2_fat+6Cr
p_dirent	dw 0			; DATA XREF: srch_fat+7Er srch_fat+92r
					; ...
word_A15_7B1	dw 0			; DATA XREF: fat_rdwr+122w
					; fat_rdwr+159w ...
monthDays	dw 0, 31, 59, 90, 120, 151, 181, 212, 243, 273,	304, 334; DATA XREF: dos_date_to_cpm+9o
					; timestamp_2_fat+32o
					; ...
fat_file_ptr	dw 0,0			; DATA XREF: fat_rdwr+B8w fat_rdwr+22Dr
					; ...
fat_day		db 0			; DATA XREF: fat_get_date+21w
					; fat_set_date+4r ...
fat_month	db 0			; DATA XREF: fat_get_date+19w
					; fat_set_date+Br ...
fat_year	db 0			; DATA XREF: fat_get_date+Cw
					; fat_set_date+13r ...
fat_hour	db 0			; DATA XREF: fat_get_date+41w
					; fat_set_date+1Ar ...
fat_minute	db 0			; DATA XREF: fat_get_date+39w
					; fat_set_date+21r ...
fat_second	db 0			; DATA XREF: fat_get_date+2Cw
					; fat_set_date+29r ...
fat_deblock?	db 0			; DATA XREF: fat_rdwr+28Fw
					; fat_rdwr+296w ...
nearby_cluster	dw 0			; DATA XREF: fat_make+30w fat_make+42r
					; ...
fat_rdwr_flg1	db 0			; DATA XREF: fat_rdwr+5w fat_rdwr+55w
					; ...
c2f_S2		db 0			; DATA XREF: c2f_to_extent+2r
					; fat_rdwr+92w	...
c2f_EX		db 0			; DATA XREF: c2f_to_extent+9r
					; fat_rdwr+96w	...
c2f_RC		db 0			; DATA XREF: fat_rdwr+9Aw fat_rdwr+356r
int13_func	db 0			; DATA XREF: F_BDOS_75+2o F_BDOS_75+2Cr
					; ...
int13_drive	db 0			; DATA XREF: F_BDOS_75+10r
int13_sectors	db 0			; DATA XREF: F_BDOS_75+26r
int13_head	db 0			; DATA XREF: F_BDOS_75+3Br
int13_sector	db 0			; DATA XREF: F_BDOS_75+35r
					; F_BDOS_75+99r
int13_cylinder	db 0			; DATA XREF: F_BDOS_75+3Fr
int13_buffer	dw 0,0			; DATA XREF: F_BDOS_75+20r
					; F_BDOS_75+1Ar
cur_drvdir	dw 0			; DATA XREF: read$subdirr rd$parentdir+6r
					; ...
dname_cluster	dw 0			; DATA XREF: set$end$dir+6w
					; rd$subdir1+9r ...
names_per_block	dw 0			; DATA XREF: rd$subdir1+20r
					; rd$subdir1+61r ...
chdir_drive	db 0			; DATA XREF: curselect_dir+Cw
					; cpm_opendir+51r
max_cluster	dw 0			; DATA XREF: drive_login+30w
					; drive_login+38w ...
dirname_0	rw 10h			; DATA XREF: proc1:0011o
		dw 1
		dw 0
dirname_1	dw offset dirname_2	; DATA XREF: dseg:0192o
		rw 11h
dirname_2	dw offset dirname_3	; DATA XREF: dseg:0813o
		rw 11h
dirname_3	dw 0			; DATA XREF: dseg:0837o
		rw 11h
dirdata_0	dw offset dirdata_1	; DATA XREF: dseg:0194o
		rw 4
dirdata_1	dw offset dirdata_2	; DATA XREF: dseg:087Fo
		rw 4
dirdata_2	dw offset dirdata_3	; DATA XREF: dseg:0889o
		rw 4
dirdata_3	dw offset dirdata_4	; DATA XREF: dseg:0893o
		rw 4
dirdata_4	dw offset dirdata_5	; DATA XREF: dseg:089Do
		rw 4
dirdata_5	dw offset dirdata_6	; DATA XREF: dseg:08A7o
		rw 4
dirdata_6	dw offset dirdata_7	; DATA XREF: dseg:08B1o
		rw 4
dirdata_7	dw 0			; DATA XREF: dseg:08BBo
		rw 4
;
; PADDING: The next module must be on a paragraph boundary
;
		rs 16
